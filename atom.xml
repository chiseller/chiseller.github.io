<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fingle</title>
  
  <subtitle>fingle</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chiseller.github.io/"/>
  <updated>2020-09-09T12:57:08.441Z</updated>
  <id>https://chiseller.github.io/</id>
  
  <author>
    <name>fingle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>技术支持</title>
    <link href="https://chiseller.github.io/2020/09/07/%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81/"/>
    <id>https://chiseller.github.io/2020/09/07/技术支持/</id>
    <published>2020-09-07T12:40:38.000Z</published>
    <updated>2020-09-09T12:57:08.441Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一-如何同步设备信息"><a href="#一-如何同步设备信息" class="headerlink" title="一. 如何同步设备信息?"></a>一. 如何同步设备信息?</h5><blockquote><p>确保设备处于“已绑定”的情况下，点击云端“刷新”按钮即可绑定设备至当前APP登录账户   </p></blockquote><h5 id="二-同步后有什么好处？"><a href="#二-同步后有什么好处？" class="headerlink" title="二. 同步后有什么好处？"></a>二. 同步后有什么好处？</h5><blockquote><p>绑定设备发出的告警信息将实时正确推送至对应的APP，或者发短信至对应手机号码  </p></blockquote><h5 id="三-如何对设备进行续费？"><a href="#三-如何对设备进行续费？" class="headerlink" title="三. 如何对设备进行续费？"></a>三. 如何对设备进行续费？</h5><blockquote><p>点击续费按钮查看金额，然后通过支付宝进行充值，在充值完成后即可通过续费功能续费。</p></blockquote><h5 id="四-联系方式"><a href="#四-联系方式" class="headerlink" title="四. 联系方式"></a>四. 联系方式</h5><blockquote><p>售前邮箱： Biz@smartreefs.com<br>技术支持： reffe@qq.com</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;一-如何同步设备信息&quot;&gt;&lt;a href=&quot;#一-如何同步设备信息&quot; class=&quot;headerlink&quot; title=&quot;一. 如何同步设备信息?&quot;&gt;&lt;/a&gt;一. 如何同步设备信息?&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;确保设备处于“已绑定”的情况下，点击云端“
      
    
    </summary>
    
      <category term="App" scheme="https://chiseller.github.io/categories/App/"/>
    
    
      <category term="Support" scheme="https://chiseller.github.io/tags/Support/"/>
    
  </entry>
  
  <entry>
    <title>HTTP与HTTPS握手的那些事</title>
    <link href="https://chiseller.github.io/2018/05/22/HTTP%E4%B8%8EHTTPS/"/>
    <id>https://chiseller.github.io/2018/05/22/HTTP与HTTPS/</id>
    <published>2018-05-22T12:40:38.000Z</published>
    <updated>2020-09-09T12:36:27.002Z</updated>
    
    <content type="html"><![CDATA[<p>HTTPS握手的过程以及为什么HTTPS是安全的。在讲述这两个握手时候，有一些东西需要提前说明。<br><a id="more"></a>  </p><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><h5 id="1-HTTP与TCP-IP区别？"><a href="#1-HTTP与TCP-IP区别？" class="headerlink" title="1. HTTP与TCP/IP区别？"></a>1. HTTP与TCP/IP区别？</h5><p>TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。下面的图表试图显示不同的TCP/IP和其他的协议在最初OSI（Open System Interconnect）模型中的位置：     </p><table><thead><tr><th style="text-align:left">分层</th><th style="text-align:center">名称</th><th style="text-align:right">协议</th></tr></thead><tbody><tr><td style="text-align:left">7</td><td style="text-align:center">应用层</td><td style="text-align:right">HTTP、SMTP、SNMP、FTP、Telnet、SP、SSH、NFS、RTSP、XMPP、Whois、ENRP</td></tr><tr><td style="text-align:left">6</td><td style="text-align:center">表示层</td><td style="text-align:right">XDR、ASN1、SMB、AFP、NCP</td></tr><tr><td style="text-align:left">5</td><td style="text-align:center">会话层</td><td style="text-align:right">ASAP、TLS、SSH、ISO8327/ CCITT X225、RPC、 NetBIOS、ASP、 Winsock、 BSD Sock</td></tr><tr><td style="text-align:left">4</td><td style="text-align:center">传输层</td><td style="text-align:right">TCP、UDP、RTP、SCTP、SPX、ATPIL</td></tr><tr><td style="text-align:left">3</td><td style="text-align:center">网络层</td><td style="text-align:right">IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X25</td></tr><tr><td style="text-align:left">2</td><td style="text-align:center">数据链路层</td><td style="text-align:right">以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE802.11、FDDI、PPP</td></tr><tr><td style="text-align:left">1</td><td style="text-align:center">物理层</td><td style="text-align:right">线路、无线电、光纤、信鸽</td></tr></tbody></table><h5 id="2-CA证书是什么？"><a href="#2-CA证书是什么？" class="headerlink" title="2. CA证书是什么？"></a>2. CA证书是什么？</h5><p>CA（Certificate Authority）是负责管理和签发证书的第三方权威机构，是所有行业和公众都信任的、认可的。CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。</p><h3 id="二、HTTP三次握手"><a href="#二、HTTP三次握手" class="headerlink" title="二、HTTP三次握手"></a>二、HTTP三次握手</h3><p>HTTP（HyperText Transfer Protocol)超文本传输协议是互联网上应用最为广泛的一种网络协议。由于信息是明文传输，所以被认为是不安全的。而关于HTTP的三次握手，其实就是使用三次TCP握手确认建立一个HTTP连接。如下图所示，SYN（synchronous）是TCP/IP建立连接时使用的握手信号、Sequence number（序列号）、Acknowledge number（确认号码），三个箭头指向就代表三次握手，完成三次握手，客户端与服务器开始传送数据。<br><img src="HTTP与HTTPS/http.jpg" alt="http握手过程">     </p><p><strong>1. 第一次握手：</strong><br>  客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br><strong>2. 第二次握手：</strong><br>服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br><strong>3. 第三次握手：</strong><br>客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。   </p><h3 id="三、HTTPS握手过程"><a href="#三、HTTPS握手过程" class="headerlink" title="三、HTTPS握手过程"></a>三、HTTPS握手过程</h3><p>HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。具体是如何进行加密，解密，验证的，且看下图，下面的称为一次握手。<br><img src="HTTP与HTTPS/https.png" alt="https握手过程">     </p><p><strong>1. 客户端发起HTTPS请求</strong></p><p><strong>2. 服务端的配置</strong></p><p>采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。</p><p><strong>3. 传送证书</strong></p><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。</p><p><strong>4. 客户端解析证书</strong></p><p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。</p><p><strong>5. 传送加密信息</strong></p><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><p><strong>6. 服务段解密信息</strong></p><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><p><strong>7. 传输加密后的信息</strong></p><p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p><p><strong>8. 客户端解密信息</strong></p><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。</p><p>###三、HTTPS一般使用的加密与HASH算法：</p><p>非对称加密算法：RSA，DSA/DSS</p><p>对称加密算法：AES，RC4，3DES</p><p>HASH算法：MD5，SHA1，SHA256</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTPS握手的过程以及为什么HTTPS是安全的。在讲述这两个握手时候，有一些东西需要提前说明。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://chiseller.github.io/categories/iOS/"/>
    
    
      <category term="Works" scheme="https://chiseller.github.io/tags/Works/"/>
    
  </entry>
  
  <entry>
    <title>我的作品链接</title>
    <link href="https://chiseller.github.io/2018/05/22/%E6%88%91%E7%9A%84%E4%BD%9C%E5%93%81%E9%93%BE%E6%8E%A5/"/>
    <id>https://chiseller.github.io/2018/05/22/我的作品链接/</id>
    <published>2018-05-22T12:40:38.000Z</published>
    <updated>2020-09-09T12:36:27.011Z</updated>
    
    <content type="html"><![CDATA[<p><code>有一部分软件已经下架或者需要硬件支持，如果不能下载请查看作品截图。</code></p><a id="more"></a>  <h5 id="一-便利家（业主）"><a href="#一-便利家（业主）" class="headerlink" title="一. 便利家（业主）"></a>一. 便利家（业主）</h5><blockquote><p>App截图（已下架）     </p></blockquote><p><img src="/2018/05/22/我的作品链接/bljyz.png" alt="便利家">   </p><h5 id="二-便利家（物业）"><a href="#二-便利家（物业）" class="headerlink" title="二. 便利家（物业）"></a>二. 便利家（物业）</h5><blockquote><p>App截图（已下架）   </p></blockquote><p><img src="/2018/05/22/我的作品链接/bljwy.png" alt="便利家">     </p><h5 id="三-到此一游"><a href="#三-到此一游" class="headerlink" title="三. 到此一游"></a>三. 到此一游</h5><blockquote><p>App截图 （已上架）   <a href="https://itunes.apple.com/cn/app/dao-ci-yi-you-just-be-here/id1056083082?mt=8" target="_blank" rel="noopener">链接</a></p></blockquote><p><img src="/2018/05/22/我的作品链接/dcyy.png" alt="便利家">   </p><h5 id="四-出格"><a href="#四-出格" class="headerlink" title="四. 出格"></a>四. 出格</h5><blockquote><p>App截图 （上架中)</p></blockquote><p><img src="/2018/05/22/我的作品链接/ah.png" alt="出格">    </p><h5 id="四-SmartReefs"><a href="#四-SmartReefs" class="headerlink" title="四. SmartReefs"></a>四. SmartReefs</h5><blockquote><p>App截图 （已上架)  <a href="https://itunes.apple.com/us/app/smartreefs/id1304223074?l=zh&amp;ls=1&amp;mt=8" target="_blank" rel="noopener">链接</a></p></blockquote><p><img src="/2018/05/22/我的作品链接/SmartReefs.png" alt="出格"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;有一部分软件已经下架或者需要硬件支持，如果不能下载请查看作品截图。&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://chiseller.github.io/categories/iOS/"/>
    
    
      <category term="Works" scheme="https://chiseller.github.io/tags/Works/"/>
    
  </entry>
  
  <entry>
    <title>iOS视频开发（二）</title>
    <link href="https://chiseller.github.io/2016/05/04/iOS%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://chiseller.github.io/2016/05/04/iOS视频开发（二）/</id>
    <published>2016-05-04T11:05:57.000Z</published>
    <updated>2020-09-09T12:36:27.010Z</updated>
    
    <content type="html"><![CDATA[<p>  此文是<code>iOS</code>视频开发的第二篇，相比第一篇来说视频和音频的可定制化更加多样化，本文总结的只是一些简单的知识，通过此文可以对音视频的采集和编辑有大致的了解。</p><h4 id="通过AVAssetWriter和AVCaptureSession"><a href="#通过AVAssetWriter和AVCaptureSession" class="headerlink" title="通过AVAssetWriter和AVCaptureSession"></a>通过<code>AVAssetWriter</code>和<code>AVCaptureSession</code></h4><p>此文系列的第一篇已经对<code>AVCaptureSession</code>录制视频的基本过程有了大致的介绍，<br><code>AVCaptureSession</code>和<code>AVAssetWriter</code>的基本步骤类似，但是通过<code>AVAssetWriter</code>可以实现更高度化的音视频编辑功能，设置视频和音频的一些属性，给视频加滤镜，音频变声等功能。<br><a id="more"></a>  </p><h5 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h5><blockquote><ol><li>初始化一个<code>AVCaptureSession</code>类   </li><li>获取音频<code>device</code>和视频<code>device</code></li><li>初始化<code>videoInput</code>&amp;<code>audioInput</code></li><li>初始化<code>videoDataOutPut</code>以及<code>audioDataOutPut</code>以及分别对应的<code>queue</code></li><li>获取<code>videoConnection</code>和<code>audioConnection</code></li><li>将<code>Input</code>和<code>output</code>加入<code>AVCaptureSession</code></li><li>初始化<code>AVAssetWriter</code></li></ol></blockquote><p>1~3请参考前文。   </p><h5 id="四、建立videoOutput和videoOutput"><a href="#四、建立videoOutput和videoOutput" class="headerlink" title="四、建立videoOutput和videoOutput"></a>四、建立<code>videoOutpu</code>t和<code>videoOutput</code></h5><pre><code>//audioOutput- (AVCaptureAudioDataOutput *)audioDataOutput{    if (!_audioDataOutput) {        _audioDataOutput = [[AVCaptureAudioDataOutput alloc]init];        //设置音频输出队列        [_audioDataOutput setSampleBufferDelegate:self queue:self.audioDataOutputQueue];    }    return _audioDataOutput;}//videoOutput-(AVCaptureVideoDataOutput *)videoDataOutput{    if (!_videoDataOutput) {        _videoDataOutput = [[AVCaptureVideoDataOutput alloc]init];        _videoDataOutput.videoSettings = nil;        _videoDataOutput.alwaysDiscardsLateVideoFrames = NO;        //设置视频输出队列        [_videoDataOutput setSampleBufferDelegate:self queue:self.videoDataOutputQueue];    }    return _videoDataOutput;}</code></pre><h5 id="五、获取videoConnection和audioConnection"><a href="#五、获取videoConnection和audioConnection" class="headerlink" title="五、获取videoConnection和audioConnection"></a>五、获取videoConnection和audioConnection</h5><pre><code>_videoConnection = [self.videoDataOutput connectionWithMediaType:AVMediaTypeVideo];_audioConnection = [self.audioDataOutput connectionWithMediaType:AVMediaTypeAudio];</code></pre><h5 id="6、将Input和output加入AVCaptureSession"><a href="#6、将Input和output加入AVCaptureSession" class="headerlink" title="6、将Input和output加入AVCaptureSession"></a>6、将<code>Input</code>和<code>output</code>加入<code>AVCaptureSession</code></h5><pre><code> _session = [[AVCaptureSession alloc]init];        //        设置视频质量        if ([_session canSetSessionPreset:AVCaptureSessionPresetHigh]) {            [_session setSessionPreset:AVCaptureSessionPresetHigh];        }        if ([_session canAddInput:self.videoInput]) {            [_session addInput:self.videoInput];        }        if ([_session canAddInput:self.audioInput]) {            [_session addInput:self.audioInput];        }        if ([_session canAddOutput:self.videoDataOutput]) {            [_session addOutput:self.videoDataOutput];        }        _videoConnection = [self.videoDataOutput connectionWithMediaType:AVMediaTypeVideo];        if ([_session canAddOutput:self.audioDataOutput]) {            [_session addOutput:self.audioDataOutput];        }        _audioConnection = [self.audioDataOutput connectionWithMediaType:AVMediaTypeAudio];</code></pre><h5 id="七、AVAssetWriter"><a href="#七、AVAssetWriter" class="headerlink" title="七、AVAssetWriter"></a>七、<code>AVAssetWriter</code></h5><pre><code>//一个url路径对应一个AVAssetWriter _assetWriter = [[AVAssetWriter alloc]initWithURL:filePathUrl fileType:AVFileTypeQuickTimeMovie error:&amp;error];    if (error) {        NSLog(@&quot;%@&quot;,error.localizedDescription);        return;    }    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{        @autoreleasepool {//            视频属性            if ([_assetWriter canApplyOutputSettings:self.videoCompressionSettings forMediaType:AVMediaTypeVideo]) {                self.videoAssetWriterInput = [[AVAssetWriterInput alloc]initWithMediaType:AVMediaTypeVideo outputSettings:self.videoCompressionSettings];                self.videoAssetWriterInput.expectsMediaDataInRealTime = YES;                if([_assetWriter canAddInput:self.videoAssetWriterInput]){                    [_assetWriter addInput:self.videoAssetWriterInput];                }            }//            音频属性 NSDictionary *  audioSettings = @{ AVFormatIDKey : @(kAudioFormatMPEG4AAC) };            if ([_assetWriter canApplyOutputSettings:audioSettings forMediaType:AVMediaTypeAudio]) {                self.audioAssetWriterInput = [[AVAssetWriterInput alloc]initWithMediaType:AVMediaTypeAudio outputSettings:audioSettings sourceFormatHint:self.outputAudioFormatDescription];                self.audioAssetWriterInput.expectsMediaDataInRealTime = YES;                if ([_assetWriter canAddInput:self.audioAssetWriterInput]) {                    [_assetWriter addInput:self.audioAssetWriterInput];                }            }            [_assetWriter startWriting];        }    });</code></pre><h5 id="代理中写入CMSampleBufferRef"><a href="#代理中写入CMSampleBufferRef" class="headerlink" title="代理中写入CMSampleBufferRef"></a>代理中写入<code>CMSampleBufferRef</code></h5><pre><code>- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection{    //    不要渲染第一个采样缓冲区。 第一个采样缓冲区标识视频的信息    //    提供(33ms at 30fps)针间隔    //    最好异步执行，防止在帧无法在读写比较慢的设备上缓存    //    当视频的设置更改之后，此信息也需要更新    CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer);    CFRetain(sampleBuffer);    if (connection == self.videoConnection) {        if (self.outputVideoFormatDescription == nil) {            self.outputVideoFormatDescription = formatDescription;        }else{            self.outputVideoFormatDescription = formatDescription;            dispatch_async(self.writingQueue, ^{                @autoreleasepool {                    @synchronized(self){                        if (_assetWriter.status != 1) {                            CFRelease(sampleBuffer);                            return ;                        }                        if (!_sessionStart) {                            [_assetWriter startSessionAtSourceTime:CMSampleBufferGetPresentationTimeStamp(sampleBuffer)];                            _sessionStart = YES;                        }                        if (self.videoAssetWriterInput.readyForMoreMediaData &amp;&amp; _assetWriter.status ==1) {                           BOOL su = [self.videoAssetWriterInput appendSampleBuffer:sampleBuffer];                            if (!su) {                                NSLog(@&quot;%@ ---video&quot;, _assetWriter.error.localizedDescription);                            }                        }                        CFRelease(sampleBuffer);                    }                }            });        }    }else if(connection == self.audioConnection){        self.outputAudioFormatDescription = formatDescription;        dispatch_async(self.writingQueue, ^{        @synchronized(self){            if (_assetWriter.status != 1) {                CFRelease(sampleBuffer);                return;            }            if(self.audioAssetWriterInput.readyForMoreMediaData &amp;&amp; _assetWriter.status == 1){               BOOL su =  [self.audioAssetWriterInput appendSampleBuffer:sampleBuffer];                if (!su) {                    NSLog(@&quot;%@&quot;,_assetWriter.error.localizedDescription);                }            }            CFRelease(sampleBuffer);        }        });    }}</code></pre><p>大致就是这么一个流程，但是其中涉及的东西特别多，还不能一一的列举出来，接下来的时间里再慢慢研究这方面的东西吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  此文是&lt;code&gt;iOS&lt;/code&gt;视频开发的第二篇，相比第一篇来说视频和音频的可定制化更加多样化，本文总结的只是一些简单的知识，通过此文可以对音视频的采集和编辑有大致的了解。&lt;/p&gt;
&lt;h4 id=&quot;通过AVAssetWriter和AVCaptureSession&quot;&gt;&lt;a href=&quot;#通过AVAssetWriter和AVCaptureSession&quot; class=&quot;headerlink&quot; title=&quot;通过AVAssetWriter和AVCaptureSession&quot;&gt;&lt;/a&gt;通过&lt;code&gt;AVAssetWriter&lt;/code&gt;和&lt;code&gt;AVCaptureSession&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;此文系列的第一篇已经对&lt;code&gt;AVCaptureSession&lt;/code&gt;录制视频的基本过程有了大致的介绍，&lt;br&gt;&lt;code&gt;AVCaptureSession&lt;/code&gt;和&lt;code&gt;AVAssetWriter&lt;/code&gt;的基本步骤类似，但是通过&lt;code&gt;AVAssetWriter&lt;/code&gt;可以实现更高度化的音视频编辑功能，设置视频和音频的一些属性，给视频加滤镜，音频变声等功能。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://chiseller.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://chiseller.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS视频开发（一）</title>
    <link href="https://chiseller.github.io/2016/05/03/iOS%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://chiseller.github.io/2016/05/03/iOS视频开发（一）/</id>
    <published>2016-05-03T01:05:57.000Z</published>
    <updated>2020-09-09T12:36:27.009Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、UIImagePickerController"><a href="#一、UIImagePickerController" class="headerlink" title="一、UIImagePickerController"></a>一、UIImagePickerController</h3><p><code>UIImagePickerController</code>是<code>UIKit</code>框架里面的一个class，通过这个系统提供的class我们可以简单的是实现拍照、录制视频和音频。 </p><a id="more"></a>    <h5 id="三个步骤："><a href="#三个步骤：" class="headerlink" title="三个步骤："></a>三个步骤：</h5><blockquote><ol><li>当前控制器<code>present</code>一个<code>UIImagePickerController</code>类   </li><li>在当前界面就可以拍照、录制视频和音频    </li><li>实现<code>UIImagePickerController</code>的<code>delegate</code>，在<code>delegate</code>可以获取录制的视频和音频，来进行相应的操作.   </li></ol></blockquote><h5 id="定制化UIImagePickerController"><a href="#定制化UIImagePickerController" class="headerlink" title="定制化UIImagePickerController"></a>定制化UIImagePickerController</h5><pre><code class="objc">//    查看摄像头是否可用if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera] == NO) {     return;}UIImagePickerController *imagePick = [[UIImagePickerController alloc]init];imagePick.sourceType = UIImagePickerControllerSourceTypeCamera;//    我们还可以设置照片和视频拍摄的质量、是否可以开启闪光灯、是否开启手电筒//    还可以单独设置只支持视频模式//    imagePick.mediaTypes = [[NSArray alloc] initWithObjects: (NSString *) kUTTypeMovie, nil];imagePick.mediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];//    UINavigationControllerDelegate,UIImagePickerControllerDelegate;imagePick.delegate = self;//拍照或者录制结束后是否可以编辑imagePick.allowsEditing = NO;[self presentViewController:imagePick animated:YES completion:nil];</code></pre><h5 id="界面的自定义"><a href="#界面的自定义" class="headerlink" title="界面的自定义"></a>界面的自定义</h5><p><code>cameraOverlayView</code>属性可以自定义<code>UIImagePickerController</code>界面顶部的控件，但是只在<code>UIImagePickerController</code>的<code>mediaTypes</code>为<code>UIImagePickerControllerSourceTypeCamera</code>时可用。   </p><h5 id="实现UIImagePickerController的delegate"><a href="#实现UIImagePickerController的delegate" class="headerlink" title="实现UIImagePickerController的delegate"></a>实现<code>UIImagePickerController</code>的<code>delegate</code></h5><pre><code class="objectivec">- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info{    NSString *mediaType = [info objectForKey:UIImagePickerControllerMediaType];     UIImage *originalImage, *editedImage, *imageToSave;    //    处理图片    if ([mediaType isEqualToString:(NSString *)kUTTypeImage]) {        editedImage = info[UIImagePickerControllerOriginalImage];        originalImage = info[UIImagePickerControllerEditedImage];        if (editedImage) {            imageToSave = editedImage;        }else{            imageToSave = originalImage;        }        UIImageWriteToSavedPhotosAlbum(imageToSave, nil, nil, nil);    }    //处理视频    if ([mediaType isEqualToString:(NSString *)kUTTypeMovie]) {        NSString *url = [info[UIImagePickerControllerMediaURL] path];        if (UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(url)) {            UISaveVideoAtPathToSavedPhotosAlbum(url, nil, nil, nil);        }    }    [picker dismissViewControllerAnimated:YES completion:nil];}</code></pre><h3 id="二、AVCaptureSession-amp-AVCaptureMovieFileOutput"><a href="#二、AVCaptureSession-amp-AVCaptureMovieFileOutput" class="headerlink" title="二、AVCaptureSession &amp; AVCaptureMovieFileOutput"></a>二、<code>AVCaptureSession</code> &amp; <code>AVCaptureMovieFileOutput</code></h3><p>  要获取摄像机捕捉到的视频或者麦克风捕捉到的音频，我们需要对象表示<code>inputs</code>和<code>outputs</code>，并使用<code>AVCaptureSession</code>的实例来协调它们之间的数据流。   </p><blockquote><ol><li>AVCaptureDevice 对象，表示声音或者视频采集设备，对应摄像头和麦克风。</li><li>AVCaptureInput的子类，配置输入端口。</li><li>AVCaptureOutput的子类， 输出采集到的视频或者图像。</li><li>AVCaptureSession来协调从输入到输出的数据流。</li></ol></blockquote><h5 id="步骤一：-创建AVCaptureDevice-对象"><a href="#步骤一：-创建AVCaptureDevice-对象" class="headerlink" title="步骤一： 创建AVCaptureDevice 对象"></a>步骤一： 创建<code>AVCaptureDevice</code> 对象</h5><p>因为我们需要录制视频和音频所以我们需要视频的AVCaptureDevice和音频的AVCaptureDevice。   </p><pre><code class="objc">//我们同时获取了前摄像头和后摄像头因为等会我们要手动切换//获取音频device-(AVCaptureDevice *)audioDevice{    if (!_audioDevice) {        _audioDevice = [AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio].firstObject;    }    return _audioDevice;}   //后置摄像头-(AVCaptureDevice *)backVideoDevice{    if (!_backVideoDevice) {        _backVideoDevice = [self getDeviceBy:AVCaptureDevicePositionBack];        if ([self.currentVideoDevice isTorchAvailable] &amp;&amp; [_backVideoDevice isTorchModeSupported:AVCaptureTorchModeOn]) {            //可以设置是否开启闪光灯，是否开始HDR、视频防抖、白平衡什么的            //设置device之前需要先 lockForConfiguration             if ([_backVideoDevice lockForConfiguration:NULL]==YES) {                self.currentVideoDevice.torchMode = AVCaptureTorchModeOn;                [self.currentVideoDevice unlockForConfiguration];            }        }    }    }    return _backVideoDevice;}//前置摄像头-(AVCaptureDevice *)frontVideoDevice{    if (!_frontVideoDevice) {        _frontVideoDevice = [self getDeviceBy:AVCaptureDevicePositionFront];    }    return _frontVideoDevice;}</code></pre><h5 id="步骤二、配置inputs"><a href="#步骤二、配置inputs" class="headerlink" title="步骤二、配置inputs"></a>步骤二、配置inputs</h5><p>每个<code>AVCaptureDevice</code>对应一个<code>input</code>。   </p><pre><code class="objc">//audio input- (AVCaptureDeviceInput *)audioInput{    if (!_audioInput) {        NSError *error = nil;        _audioInput = [AVCaptureDeviceInput deviceInputWithDevice:self.audioDevice error:&amp;error];    }    return _audioInput;}- (AVCaptureDeviceInput *)videoInput{    if (!_videoInput) {        NSError *error  = nil;        _videoInput = [AVCaptureDeviceInput deviceInputWithDevice:self.currentVideoDevice error:&amp;error];    }    return _videoInput;}</code></pre><h5 id="步骤三-写入文件"><a href="#步骤三-写入文件" class="headerlink" title="步骤三: 写入文件"></a>步骤三: 写入文件</h5><p>Output有四种：</p><blockquote><p><code>AVCaptureMovieFileOutput</code> 写入文件<br><code>AVCaptureVideoDataOutput</code> 加工视频输出<br><code>AVCaptureAudioDataOutput</code> 加工音频输出<br><code>AVCaptureStillImageOutput</code> 捕捉输出的图像</p></blockquote><p>写入文件只需要<code>AVCaptureMovieFileOutput</code>就可以了。   </p><pre><code class="objc">// output- (AVCaptureMovieFileOutput  *)movieFileOutput{    if (!_movieFileOutput) {        _movieFileOutput = [[AVCaptureMovieFileOutput  alloc]init];        //CMTime drution = CMTimeMake(1, 60);        //设置视频录制时间限制 kCMTimeInvalid(无限制)        _movieFileOutput.maxRecordedDuration = kCMTimeInvalid;        // 文件大小限制        //_movieFileOutput.maxRecordedFileSize = 1024 * 1024;        AVCaptureConnection *videoConnection = [_movieFileOutput connectionWithMediaType:AVMediaTypeVideo];        // 是否支持科学防抖        if ([videoConnection isVideoStabilizationSupported]) {            videoConnection.preferredVideoStabilizationMode = AVCaptureVideoStabilizationModeAuto;        }        videoConnection.videoOrientation = self.previewLayer.connection.videoOrientation;    }    return _movieFileOutput;}</code></pre><h5 id="步骤四：-获取AVCaptureSession"><a href="#步骤四：-获取AVCaptureSession" class="headerlink" title="步骤四： 获取AVCaptureSession"></a>步骤四： 获取<code>AVCaptureSession</code></h5><pre><code class="objc">- (AVCaptureSession *)session{    if (!_session) {        _session = [[AVCaptureSession alloc]init];        // 设置视频质量        if ([_session canSetSessionPreset:AVCaptureSessionPresetLow]) {            [_session setSessionPreset:AVCaptureSessionPresetLow];        }        //增加videoinput        if ([_session canAddInput:self.videoInput]) {            [_session addInput:self.videoInput];        }        //增加videoinput        if ([_session canAddInput:self.audioInput]) {            [_session addInput:self.audioInput];        }        //增加fileOutput        if ([_session canAddOutput:self.movieFileOutput]) {            [_session addOutput:self.movieFileOutput];        }    }    return _session;}</code></pre><p>这个地方需要注意下，每次我们更改<code>AVCaptureSession</code>的属性的时候我们都需要：   </p><pre><code class="objc">[session beginConfiguration];// Remove an existing capture device.// Add a new capture device.// Reset the preset.[session commitConfiguration];</code></pre><h5 id="现在就可以录制视频并写入文件了"><a href="#现在就可以录制视频并写入文件了" class="headerlink" title="现在就可以录制视频并写入文件了"></a>现在就可以录制视频并写入文件了</h5><p>为了实时查看我们录制的内容，我们加一个预览层。   </p><pre><code class="objc">-(AVCaptureVideoPreviewLayer *)previewLayer{    if (!_previewLayer) {        _previewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.session];        _previewLayer.frame = [UIScreen mainScreen].bounds;        _previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill;        _previewLayer.connection.videoOrientation = AVCaptureVideoOrientationPortrait;    }    return _previewLayer;}</code></pre><p>在控制器里面调用<code>session</code>的<code>startRuning</code>方法，这个时候只是采集到了视频显示在了预览层上面，并未开始录制。</p><pre><code class="objc">- (void)viewDidLoad {    [super viewDidLoad];    self.recodingView.delegate = self;    [self.view.layer insertSublayer:self.previewLayer atIndex:0];    [self.session startRunning];}</code></pre><p>点击录制视频,<code>recodingView</code>是我自定义的控件。   </p><pre><code class="objc">-(void)writePath{    if ([self.movieFileOutput isRecording] ) {        [self.movieFileOutput stopRecording];        return;    }    NSDateFormatter * dateFormatter = [[NSDateFormatter alloc] init ];    [dateFormatter setDateFormat:@&quot;yyyyMMddHHmmss&quot;];    NSString * fileName = [[dateFormatter stringFromDate:[NSDate date]] stringByAppendingString:@&quot;.mov&quot;];    NSString * filePath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:fileName];    NSURL *filePathUrl = [NSURL fileURLWithPath:filePath];    //写文件到指定的路径，并设置代理    [self.movieFileOutput startRecordingToOutputFileURL:filePathUrl recordingDelegate:self];}</code></pre><p>设置代理,在视频录制的过程中会发生许多情况，比如说突然来电话，摄像头被其他程序占用，系统会发送相应的通知给我们。</p><pre><code class="objc">- (void)captureOutput:(AVCaptureFileOutput *)captureOutputdidFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL      fromConnections:(NSArray *)connections                error:(NSError *)error{    BOOL recordSuccessfully = YES;    if ([error code] != noErr) {        id value = [[error userInfo] objectForKey:AVErrorRecordingSuccessfullyFinishedKey];        if (value) {            recordSuccessfully = [value boolValue];        }    }//   有`error`的话 有可能也是录制成功了    /*    AVErrorMaximumDurationReached  时间限制    AVErrorMaximumFileSizeReached  文件大小限制    AVErrorDiskFull                磁盘已满    AVErrorDeviceWasDisconnected   device连接失败    AVErrorSessionWasInterrupted   被切断（比如说来电话了）*/}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、UIImagePickerController&quot;&gt;&lt;a href=&quot;#一、UIImagePickerController&quot; class=&quot;headerlink&quot; title=&quot;一、UIImagePickerController&quot;&gt;&lt;/a&gt;一、UIImagePickerController&lt;/h3&gt;&lt;p&gt;&lt;code&gt;UIImagePickerController&lt;/code&gt;是&lt;code&gt;UIKit&lt;/code&gt;框架里面的一个class，通过这个系统提供的class我们可以简单的是实现拍照、录制视频和音频。 &lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://chiseller.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://chiseller.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>在centos上搭建git服务器</title>
    <link href="https://chiseller.github.io/2015/07/02/POST%E5%92%8CPUT%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://chiseller.github.io/2015/07/02/POST和PUT请求的区别/</id>
    <published>2015-07-02T06:35:57.000Z</published>
    <updated>2020-09-09T12:36:27.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="POST和PUT请求的区别"><a href="#POST和PUT请求的区别" class="headerlink" title="POST和PUT请求的区别"></a><code>POST</code>和<code>PUT</code>请求的区别</h3><h4 id="1-什么是幂等性"><a href="#1-什么是幂等性" class="headerlink" title="1.什么是幂等性"></a>1.什么是幂等性</h4><blockquote><p><strong>幂等性概念：</strong>幂等通俗来说是指不管进行多少次重复操作，都是实现相同的结果。</p></blockquote><h4 id="2-REST请求中哪些是幂等操作"><a href="#2-REST请求中哪些是幂等操作" class="headerlink" title="2.REST请求中哪些是幂等操作"></a>2.REST请求中哪些是幂等操作</h4><p><code>GET</code>，<code>PUT</code>，<code>DELETE</code>都是幂等操作，而<code>POST</code>不是.   </p><blockquote><p>1.首先<code>GET</code>请求很好理解，对资源做查询多次，此实现的结果都是一样的。<br> 2.PUT请求的幂等性可以这样理解，将<code>A</code>修改为<code>B</code>，它第一次请求值变为了<code>B</code>，再进行多次此操作，最终的结果还是<code>B</code>，与一次执行的结果是一样的，所以<code>PUT</code>是幂等操作。<br> 3.同理可以理解<code>DELETE</code>操作，第一次将资源删除后，后面多次进行此删除请求，最终结果是一样的，将资源删除掉了。<br> 4.<code>POST</code>不是幂等操作，因为一次请求添加一份新资源，二次请求则添加了两份新资源，多次请求会产生不同的结果，因此POST不是幂等操作。</p></blockquote><p>####3 根据幂等性区分POST与PUT的使用<br>了解REST后很长一段时间不能明确区分<code>PUT</code>和<code>POST</code>的区别，在使用时很容易混淆，完全可根据<code>idempotent</code>（幂等性）做区分。</p><blockquote><p>假如有一个博客系统提供一个Web API，模式是这样<a href="http://superblogging/blogs/{blog-name}，很简单，将{blog-name}替换为我们的blog名字，往这个URI发送一个HTTP" target="_blank" rel="noopener">http://superblogging/blogs/{blog-name}，很简单，将{blog-name}替换为我们的blog名字，往这个URI发送一个HTTP</a> PUT或者POST请求，HTTP的body部分就是博文，这是一个很简单的REST API例子。</p></blockquote><p><strong>我们应该用PUT方法还是POST方法？</strong></p><blockquote><p>取决于这个<code>REST</code>服务的行为是否是<code>idempotent</code>的，假如我们发送两个<code>http://superblogging/blogs/post/Sample</code>请求，服务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是<code>idempotent</code>的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是<code>idempotent</code>的。前一种情况，应该使用<code>POST</code>方法，后一种情况，应该使用<code>PUT</code>方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;POST和PUT请求的区别&quot;&gt;&lt;a href=&quot;#POST和PUT请求的区别&quot; class=&quot;headerlink&quot; title=&quot;POST和PUT请求的区别&quot;&gt;&lt;/a&gt;&lt;code&gt;POST&lt;/code&gt;和&lt;code&gt;PUT&lt;/code&gt;请求的区别&lt;/h3&gt;&lt;h4
      
    
    </summary>
    
      <category term="linux" scheme="https://chiseller.github.io/categories/linux/"/>
    
    
      <category term="bash" scheme="https://chiseller.github.io/tags/bash/"/>
    
      <category term="git" scheme="https://chiseller.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>在centos上搭建git服务器</title>
    <link href="https://chiseller.github.io/2015/07/02/%E5%9C%A8centos%E4%B8%8A%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://chiseller.github.io/2015/07/02/在centos上搭建git服务器/</id>
    <published>2015-07-02T06:35:57.000Z</published>
    <updated>2020-09-09T12:36:27.010Z</updated>
    
    <content type="html"><![CDATA[<p>  刚开始搭建blog的时候打算用ftp的,可是期间遇到了各种问题,最后选择了git,其实现在想想遇到的大部分问题应该全是权限的问题,毕竟对linux的认识只能说算是刚刚起步,等有空的时候再去好好研究吧.   </p> <a id="more"></a><h3 id="vps-系统centos6-2-git版本1-7"><a href="#vps-系统centos6-2-git版本1-7" class="headerlink" title="vps(系统centos6.2,git版本1.7)"></a><code>vps</code>(系统<code>centos6.2</code>,<code>git</code>版本1.7)</h3><hr><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装<code>git</code></h4><p>方法一.<code>yum install -y git</code>(最简单的方法)<br>方法二.下载<code>git</code>源码编译安装,需要安装编译工具(不做介绍)</p><h4 id="建立git用户-可选"><a href="#建立git用户-可选" class="headerlink" title="建立git用户(可选)"></a>建立<code>git</code>用户(可选)</h4><p>注意:有些系统在你安装<code>git</code>的时候,可能已经给你自动建立了<code>git</code>用户,因此你可以忽略这一步.</p><p>添加git用户</p><pre><code class="bash">//自动在home下建立git目录useradd git//切换到/home下查看ls -al//注意一定要注意查看git目录的拥有者(必须是git)和所属用户组(可以是git或者root),//否则在以后设置免密码clone和push的时候会出现Permission denied error的错误.//修改git目录拥有者和所属群组为gitchown -R git:git git</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1043168-62019d6ea599afa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="F9D26F43-5BBE-4C51-8E72-8F94171EBD94.png"></p><h4 id="修改git用户的操作权限"><a href="#修改git用户的操作权限" class="headerlink" title="修改git用户的操作权限"></a>修改<code>git</code>用户的操作权限</h4><pre><code class="bash">vi /etc/passwd//找到git用户的那一行,修改如下:不允许git用户的ssh登录git:x:500:500::/home/git:/usr/bin/git-shell</code></pre><h4 id="在服务器上建立裸版本库"><a href="#在服务器上建立裸版本库" class="headerlink" title="在服务器上建立裸版本库"></a>在服务器上建立裸版本库</h4><pre><code class="bash">mkdir /home/testgit//这里 git init 是初始化空仓库的意思，而参数 --bare 是代表创建裸仓库，而参数 --bare 是代表创建裸仓库git init --bare sample.git注意:一定要查看testgit目录的拥有者(必须是git)和所属用户组(可以是git或者root),否则在以后设置免密码clone和push的时候会出现Permission denied error的错误.</code></pre><h4 id="clone远程仓库"><a href="#clone远程仓库" class="headerlink" title="clone远程仓库"></a><code>clone</code>远程仓库</h4><pre><code class="bash">cd Desktopgit clone git@115.159.146.94:/home/testgit/sample.git //这时候会让你输入git的密码,但是我们并没有设置git用户的密码</code></pre><h4 id="配置公钥进行免密码登录-clone和push"><a href="#配置公钥进行免密码登录-clone和push" class="headerlink" title="配置公钥进行免密码登录 clone和push"></a>配置公钥进行免密码登录 <code>clone</code>和<code>push</code></h4><p><code>mac</code>下的公钥和密钥在 <code>~/.ssh</code>下</p><pre><code class="bash">cd ~/.sshls -a//会看到如下文件(如果没有请查看如何生成公钥和密钥)id_rsa(密钥)   id_rsa.pub(公钥)  known_host//生成公密钥 终端ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/home/fdipzone/.ssh/id_rsa): 这里输入要生成的文件名Enter passphrase (empty for no passphrase): 这里输入密码 Enter same passphrase again: 这里重复输入密码Your identification has been saved in /home/fdipzone/.ssh/id_rsa.Your public key has been saved in /home/fdipzone/.ssh/id_rsa.pub.The key fingerprint is:f2:76:c3:6b:26:10:14:fc:43:e0:0c:4d:51:c9:a2:b0The key&#39;s randomart image is:+--[ RSA 2048]----+|    .+=*..                  ||    . += +                  || o oo+ || E . . o || ..S. || .o . || .o + || ...oo || +. |+-----------------+//密钥生成成功</code></pre><p>在<code>centos</code></p><pre><code class="bash">cd /home/git/.ssh//建立授权文件 authorized_keys,文件不存在则自己新建一个//将本地机器上的 id_rsa.pub(公钥)里面的复制一份粘贴到centos下/home/git/.ssh/authorized_keys</code></pre><p><code>authorized_keys</code>文件看起来是这样的,上下两个免密码登录用户的公钥 ,上下分开.</p><p>###注意:  <code>.ssh</code>  和 <code>authorized_keys</code>的拥有者必须是<code>git</code>,否则还是会有权限不足的问题<br><img src="http://upload-images.jianshu.io/upload_images/1043168-f05cb1189bd5290f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h4 id="同步代码到自己的博客站点目录"><a href="#同步代码到自己的博客站点目录" class="headerlink" title="同步代码到自己的博客站点目录"></a>同步代码到自己的博客站点目录</h4><p>比如说我们的博客有一点点的优化,但是<code>push</code>代码之后无法立即查看效果,这个地方我们就需要自动同步就派上用场了。自动同步功能用到的是 <code>git</code> 的钩子功能，</p><pre><code class="bash">cd /home/testgit/sample.gitcd hooks//这里我们创建post-receive文件vi post-receive//在该文件里输入以下内容./home/www就是我blog站点的目录#!/bin/bashgit --work-tree=/home/www checkout -f//保存退出后，将该文件用户及用户组都设置成gitchown git:git post-receive//由于该文件其实就是一个shell文件，我们还应该为其设置可执行权限chmod +x post-receive</code></pre><p>此时<code>clone</code>自己的<code>blog</code>站点,修改一下网站的名称,<code>push</code>到<code>git</code>服务器,刷新网站首页,是不是发现自己blog的名称变了!</p><h4 id="最后再记录一下-配置ssh-免密码登录-so-easy"><a href="#最后再记录一下-配置ssh-免密码登录-so-easy" class="headerlink" title="最后再记录一下,配置ssh 免密码登录(so easy)"></a>最后再记录一下,配置<code>ssh</code> 免密码登录(so easy)</h4><p>复制自己主机下的公钥内容<br>在自己的<code>vps</code>下</p><pre><code class="bash">vi  /root/.ssh/ authorized_keys</code></pre><p>//复制密钥内容进去,好了,现在<code>ssh</code>也可以免密码登录了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  刚开始搭建blog的时候打算用ftp的,可是期间遇到了各种问题,最后选择了git,其实现在想想遇到的大部分问题应该全是权限的问题,毕竟对linux的认识只能说算是刚刚起步,等有空的时候再去好好研究吧.   &lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://chiseller.github.io/categories/linux/"/>
    
    
      <category term="bash" scheme="https://chiseller.github.io/tags/bash/"/>
    
      <category term="git" scheme="https://chiseller.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>JavaScriptCore的基本用法（二）</title>
    <link href="https://chiseller.github.io/2015/06/08/JavaScriptCore%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%952/"/>
    <id>https://chiseller.github.io/2015/06/08/JavaScriptCore的基本用法2/</id>
    <published>2015-06-07T16:00:00.000Z</published>
    <updated>2020-09-09T12:36:27.007Z</updated>
    
    <content type="html"><![CDATA[<p>  这是<code>JavaScriptCore</code>的第二篇<br><a id="more"></a></p><h3 id="代理设置（JS调用OC的第二种方法）"><a href="#代理设置（JS调用OC的第二种方法）" class="headerlink" title="代理设置（JS调用OC的第二种方法）"></a>代理设置（<code>JS</code>调用<code>OC</code>的第二种方法）</h3><p><code>h文件</code></p><pre><code class="objc">//首先写一个协议  遵守JSExport协议@protocol JSExportTest &lt;JSExport&gt;//宏转换下，将JS函数名称指定为Add；JSExportAs(add, - (NSInteger)add:(NSInteger)a b:(NSInteger)b);@property (nonatomic, assign) NSInteger sum;@end//建一个对象实现这个协议@interface JSTest : NSObject&lt;JSExportTest&gt;@end</code></pre><p><code>m文件</code></p><pre><code class="objc">@implementation JSTest@synthesize sum = _sum;//实现协议方法- (NSInteger)add:(NSInteger)a b:(NSInteger)b{return a + b;}-(void)setSum:(NSInteger)sum{NSLog(@&quot;%ld&quot;,(long)sum);_sum = sum;}@end</code></pre><p>在viewcontroller里面</p><pre><code class="objc">JSContext *context = [[JSContext alloc] init];//设置异常处理self.context.exceptionHandler = ^(JSContext *context, JSValue *exception) {[JSContext currentContext].exception = exception;NSLog(@&quot;exception:%@&quot;,exception);};//将obj添加到context中scontext[@&quot;obj&quot;] = [][JSTest alloc]init];//JS里面调用obj方法，并将结果赋值给obj的sum属性[context evaluateScript:@&quot;obj.sum = obj.add(2,3)&quot;];</code></pre><p>在<code>JS</code>中进行调用这个对象的方法，并将结果赋值<code>sum</code>。唯一要注意的是<code>OC</code>的函数命名和<code>JS</code>函数命名规则问题。协议中定义的是<code>add: b:</code>，但是<code>JS</code>里面方法名字是<code>add(a,b)</code>。可以通过<code>JSExportAs</code>这个宏转换成<code>JS</code>的函数名字。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><code>Objective-C</code>的异常会在运行时被<code>Xcode</code>捕获，而在<code>JSContext</code>中执行的<code>JavaScript</code>如果出现异常，只会被<code>JSContext</code>捕获并存储在<code>exception</code>属性上，而不会向外抛出。时时刻刻检查<code>JSContext</code>对象的<code>exception</code>是否不为<code>nil</code>显然是不合适，更合理的方式是给<code>JSContext</code>对象设置<code>exceptionHandler</code>，它接受的是<code>^(JSContext *context, JSValue *exceptionValue)</code>形式的<code>Block</code>。其默认值就是将传入的<code>exceptionValue</code>赋给传入的<code>context的exception</code>属性：</p><pre><code class="objc">JSContext *context = [[JSContext alloc] init];context.exceptionHandler = ^(JSContext *con, JSValue *exception) {NSLog(@&quot;%@&quot;, exception);con.exception = exception;};[context evaluateScript:@&quot;fengzhen = 66&quot;];//输出://  ReferenceError: Can&#39;t find variable: fengzhen</code></pre><p>无论是把<code>Block</code>传给<code>JSContext</code>对象让其变成<code>avaScript</code>方法，还是把它赋给<code>exceptionHandler</code>属性，在<code>Block</code>内都不要直接使用其外部定义的<code>JSContext</code>对象或者JSValue，应该将其当做参数传入到<code>Block</code>中，或者通过<code>JSContext</code>的类方法<code>+ (JSContext *)currentContext;</code>来获得。否则会造成循环引用使得内存无法被正确释放。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p><code>OC</code>使用的是<code>ARC</code>，<code>JS</code>使用的是垃圾回收机制，js的引用全都是强引用，垃圾回收机制会帮他们打破这种强引用，所以JS不存在循环引用的问题。一般情况下，<code>OC</code>和<code>JS</code>对象之间内存管理都无需我们去关心。不过还是有几个注意点需要我们去留意下。</p><h4 id="不要在block里面直接使用context，或者使用外部的JSValue对象。"><a href="#不要在block里面直接使用context，或者使用外部的JSValue对象。" class="headerlink" title="不要在block里面直接使用context，或者使用外部的JSValue对象。"></a>不要在<code>block</code>里面直接使用<code>context</code>，或者使用外部的<code>JSValue</code>对象。</h4><pre><code class="objc">JSContext *context = [[JSContext alloc] init];//设置异常处理self.context.exceptionHandler = ^(JSContext *context, JSValue *exception) {//直接这么使用是错误的//context.exception = exception;[JSContext currentContext].exception = exception;NSLog(@&quot;exception:%@&quot;,exception);};</code></pre><h4 id="OC对象不要用属性直接保存JSValue对象，因为这样太容易造成循环引用。"><a href="#OC对象不要用属性直接保存JSValue对象，因为这样太容易造成循环引用。" class="headerlink" title="OC对象不要用属性直接保存JSValue对象，因为这样太容易造成循环引用。"></a><code>OC</code>对象不要用属性直接保存<code>JSValue</code>对象，因为这样太容易造成循环引用。</h4><p>下面的例子：</p><pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;#import &lt;JavaScriptCore/JavaScriptCore.h&gt;//首先写一个协议  遵守JSExport协议@protocol JSExportTest &lt;JSExport&gt;//宏转换下，将JS函数名称指定为Add；JSExportAs(add, - (NSInteger)add:(NSInteger)a b:(NSInteger)b);@property (nonatomic, strong) JSValue *value;@end//建一个对象实现这个协议@interface JSTest : NSObject&lt;JSExportTest&gt;@end</code></pre><pre><code class="objc">#import &quot;JSTest.h&quot;@implementation JSTest@synthesize value = _value;//实现协议方法-(void)setValue:(JSValue *)value{_value = value;}@end</code></pre><p><code>viewController里面</code></p><pre><code class="objc">JSContext *context = [[JSContext alloc]init];context.exceptionHandler = ^(JSContext *j, JSValue *v){NSLog(@&quot;%@&quot;,j.exception);};[context evaluateScript:@&quot;function callback(){return &#39;hello world&#39;};function setObj(obj){this.obj = obj;obj.value = callback}&quot;];[context[@&quot;setObj&quot;] callWithArguments:@[self.testObj]];</code></pre><p>调用<code>JS</code>方法，进行赋值，JS对象保留了传进来的obj，最后，JS将自己的回调callback赋值给了obj，方便obj下次回调给JS；由于JS那边保存了obj，而且obj这边也保留了JS的回调。这样就形成了循环引用。<br>为了打破这种强引用，apple有一个JSManagedValue 的类，官方的原话：</p><pre><code class="objc">The JSManagedValue&#39;s JavaScript value is reachable from JavaScriptThe owner of the managed reference is reachable in Objective-C. Manually adding or removing the managed reference in the JSVirtualMachine determines reachability.</code></pre><p>JSManagedValue 帮助我们保存JSValue，里面保存的JS对象必须在JS中存在，同时 JSManagedValue 的owner在OC中也存在.因此我们把代理的m文件修改如下：</p><pre><code class="objc">-(void)setValue:(JSValue *)value{//    由于是回掉的关系  obj保存了JS的回掉， js也保存了obj，这样就形成了循环引用//    JSManageValue帮助我们保存了JSValue，哪里保存的js对象在js中存在。 JSMangerValue的owner在OC中也存在。JSManagedValue *mavalue = [JSManagedValue managedValueWithValue:value];//建立弱引用关系[[[JSContext  currentContext] virtualMachine] addManagedReference:mavalue withOwner:self];_value = value;}</code></pre><h4 id="不要在不同的-JSVirtualMachine-之间进行传递JS对象。"><a href="#不要在不同的-JSVirtualMachine-之间进行传递JS对象。" class="headerlink" title="不要在不同的 JSVirtualMachine 之间进行传递JS对象。"></a>不要在不同的 JSVirtualMachine 之间进行传递JS对象。</h4><p>一个JSVirtualMachine可以运行多个context，由于都是在同一个堆内存和同一个垃圾回收下，所以相互之间传值是没问题的。但是如果在不同的 JSVirtualMachine传值，垃圾回收就不知道他们之间的关系了，可能会引起异常。</p><h4 id="JavaScriptCore线程是安全的。"><a href="#JavaScriptCore线程是安全的。" class="headerlink" title="JavaScriptCore线程是安全的。"></a>JavaScriptCore线程是安全的。</h4><p>每个context运行的时候通过lock关联的JSVirtualMachine。如果要进行并发操作，可以创建多个JSVirtualMachine实例进行操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  这是&lt;code&gt;JavaScriptCore&lt;/code&gt;的第二篇&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://chiseller.github.io/categories/iOS/"/>
    
    
      <category term="JavaScript" scheme="https://chiseller.github.io/tags/JavaScript/"/>
    
      <category term="iOS" scheme="https://chiseller.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScriptCore的基本用法（一）</title>
    <link href="https://chiseller.github.io/2015/06/01/JavaScriptCore%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%951/"/>
    <id>https://chiseller.github.io/2015/06/01/JavaScriptCore的基本用法1/</id>
    <published>2015-05-31T16:00:00.000Z</published>
    <updated>2020-09-09T12:36:27.005Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScriptCore简介"><a href="#JavaScriptCore简介" class="headerlink" title="JavaScriptCore简介"></a>JavaScriptCore简介</h3><p>iOS 7中加入了<code>JavaScriptCore</code>框架。该框架让<code>Objective-C</code>和<code>JavaScript</code>代码直接的交互变得更加的简单方便。而且使得js可以脱离webview与oc交互。<br><a id="more"></a><br>在项目中引入JavaScriptCore后，链到头文件中，除了大段的Copyright注释可以看到里面只要引入了5个文件，每个文件里都定义跟文件名对应的类：<br><img src="/2015/06/01/JavaScriptCore的基本用法1/logo.png" alt="JavaScriptCore"></p><h4 id="JSContext和JSValue"><a href="#JSContext和JSValue" class="headerlink" title="JSContext和JSValue"></a>JSContext和JSValue</h4><h5 id="JSContext"><a href="#JSContext" class="headerlink" title="JSContext"></a>JSContext</h5><pre><code class="mm">//JSVirtualMachine为JavaScript的运行提供了底层资源，JSContext就为其提供着运行环境,该方法用来执行一段//JS代码，并且如果其中有方法、变量等信息都会被存储在其中以便在需要的时候使用。- (JSValue *)evaluateScript:(NSString *)script//JSContext的创建都是基于JSVirtualMachine,如果是使用- (id)init;//进行初始化，那么在其内部会自动创建一个新的JSVirtualMachine//对象然后调用前边的初始化方法- (id)initWithVirtualMachine:(JSVirtualMachine *)virtualMachine;</code></pre><h5 id="JSValue"><a href="#JSValue" class="headerlink" title="JSValue"></a>JSValue</h5><p>则可以说是JavaScript和Object-C之间互换的桥梁，它提供了多种方法可以方便地把JavaScript数据类型转换成Objective-C，或者是转换过去。其一一对应方式可见下表：<br><img src="/2015/06/01/JavaScriptCore的基本用法1/javaScriptCoreObject.jpeg" alt="JavaScript对象和OC对象的对应关系"></p><h3 id="基本类型的转换"><a href="#基本类型的转换" class="headerlink" title="基本类型的转换"></a>基本类型的转换</h3><pre><code class="objc">JSContext *context = [[JSContext alloc] init];JSValue *jsVal = [context evaluateScript:@&quot;2+7&quot;];int iVal = [jsVal toInt32];NSLog(@&quot;JSValue: %@, int: %d&quot;, jsVal, iVal);//输出9</code></pre><p>还可以存一个Js变量在JSContext中，然后通过下标取出来。对于数组或者对象类型，JSValue也可以通过下表直接取值和赋值.</p><pre><code class="objc">[context evaluateScript:@&quot;var arr = [21, 7 ,&#39;leo&#39;]&quot;];JSValue *value = context[@&quot;arr&quot;];value[1] = @&quot;blog&quot;;value[7] = @7;NSArray *array = [value toArray];打印数组看一下Printing description of array:&lt;__NSArrayM 0x7fabc144ea40&gt;(21,blog,leo,&lt;null&gt;,&lt;null&gt;,&lt;null&gt;,&lt;null&gt;,7</code></pre><p>代码成功把数据从OC赋值到了Js数组上，而且jsValue遵循js数组的特性，无下标越位，自动延展数组大小</p><h3 id="方法的转换（js调用oc的第一种方法）"><a href="#方法的转换（js调用oc的第一种方法）" class="headerlink" title="方法的转换（js调用oc的第一种方法）"></a>方法的转换（js调用oc的第一种方法）</h3><p>各种数据类型可以转换，Objective-C的Block也可以传入JSContext中当做JavaScript的方法使用。</p><pre><code class="objc">context[@&quot;add&quot;] = ^(NSInteger a, NSInteger b){//获取该方法的对象JSValue *v = [JSContext currentThis];//获取当前的参数NSArray *args = [JSContext currentArguments];NSLog(@&quot;当前对象：%@&quot;,v);NSLog(@&quot;当前参数：%@&quot;,args);NSLog(@&quot;和是%ld&quot;,a + b);};[context evaluateScript:@&quot;add(1,2)&quot;];输出如下：当前对象：GlobalObject当前参数：(1,2)和是3</code></pre><p>上边的例子中对于”this”输出的内容是GlobalObject，这也是JSContext对象方法- (JSValue *)globalObject;所返回的内容。因为我们知道在JavaScript里，所有全局变量和方法其实都是一个全局变量的属性，在浏览器中是window，在JavaScriptCore是什么就不得而知了。</p><p>Block可以传入JSContext作方法，但是JSValue没有toBlock方法来把JavaScript方法变成Block在Objetive-C中使用。毕竟Block的参数个数和类型已经返回类型都是固定的。虽然不能把方法提取出来，但是JSValue提供了- (JSValue <em>)callWithArguments:(NSArray </em>)arguments;方法可以反过来将参数传进去来调用方法。</p><pre><code class="objc">JSContext *context = [[JSContext alloc]init];NSString *js = @&quot;function add(a,b){return a+ b;}&quot;;[context evaluateScript:js];JSValue *value = [context[@&quot;add&quot;] callWithArguments:@[@3,@4]];NSLog(@&quot;%@&quot;,value);输出如下：7</code></pre><p>JSValue还提供</p><pre><code class="objc">- (JSValue *)invokeMethod:(NSString *)method withArguments:(NSArray *)arguments;</code></pre><p>让我们可以直接简单地调用对象上的方法。只是如果定义的方法是全局函数，那么很显然应该在JSContext的globalObject对象上调用该方法；如果是某JavaScript对象上的方法，就应该用相应的JSValue对象调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JavaScriptCore简介&quot;&gt;&lt;a href=&quot;#JavaScriptCore简介&quot; class=&quot;headerlink&quot; title=&quot;JavaScriptCore简介&quot;&gt;&lt;/a&gt;JavaScriptCore简介&lt;/h3&gt;&lt;p&gt;iOS 7中加入了&lt;code&gt;JavaScriptCore&lt;/code&gt;框架。该框架让&lt;code&gt;Objective-C&lt;/code&gt;和&lt;code&gt;JavaScript&lt;/code&gt;代码直接的交互变得更加的简单方便。而且使得js可以脱离webview与oc交互。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://chiseller.github.io/categories/iOS/"/>
    
    
      <category term="JavaScript" scheme="https://chiseller.github.io/tags/JavaScript/"/>
    
      <category term="iOS" scheme="https://chiseller.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Mac终端制作带密码的压缩包</title>
    <link href="https://chiseller.github.io/2015/05/07/Mac%E7%BB%88%E7%AB%AF%E5%88%B6%E4%BD%9C%E5%B8%A6%E5%AF%86%E7%A0%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%8C%85/"/>
    <id>https://chiseller.github.io/2015/05/07/Mac终端制作带密码的压缩包/</id>
    <published>2015-05-07T03:35:57.000Z</published>
    <updated>2020-09-09T12:36:27.008Z</updated>
    
    <content type="html"><![CDATA[<p>刚在网上闲逛看到的，记录一下，以备不时之需 ^_^！<br><a id="more"></a>  </p><h4 id="1-只压缩单个文件"><a href="#1-只压缩单个文件" class="headerlink" title="1. 只压缩单个文件"></a>1. 只压缩单个文件</h4><p><code>zip -e yourZipFileName.zip yourSourceFile</code><br>回车 ，分别输入密码（回车）和确认密码（回车）就OK了。</p><h5 id="2-压缩文件夹"><a href="#2-压缩文件夹" class="headerlink" title="2. 压缩文件夹"></a>2. 压缩文件夹</h5><p><code>zip -e -r yourZipFileName.zip yourSourceFileDir</code></p><h5 id="3-一行行命令搞定"><a href="#3-一行行命令搞定" class="headerlink" title="3. 一行行命令搞定"></a>3. 一行行命令搞定</h5><p><code>zip -r -P yourPassword yourZipFileName.zip yourSourceFileDir</code></p><h5 id="注意：万一输错密码就悲剧了！！！！！！！"><a href="#注意：万一输错密码就悲剧了！！！！！！！" class="headerlink" title="注意：万一输错密码就悲剧了！！！！！！！"></a>注意：万一输错密码就悲剧了！！！！！！！</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚在网上闲逛看到的，记录一下，以备不时之需 ^_^！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="https://chiseller.github.io/categories/Mac/"/>
    
    
      <category term="bash" scheme="https://chiseller.github.io/tags/bash/"/>
    
      <category term="Mac" scheme="https://chiseller.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac搭建PHP开发环境</title>
    <link href="https://chiseller.github.io/2015/05/03/Mac%E6%90%AD%E5%BB%BAPHP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://chiseller.github.io/2015/05/03/Mac搭建PHP开发环境/</id>
    <published>2015-05-03T01:05:57.000Z</published>
    <updated>2020-09-09T12:36:27.007Z</updated>
    
    <content type="html"><![CDATA[<p><code>Mac</code>搭建<code>PHP</code>开发环境(<code>mamp</code>+<code>phpstorm</code>+<code>xdebug</code>)<br><a id="more"></a></p><h4 id="OS版本"><a href="#OS版本" class="headerlink" title="OS版本"></a><code>OS</code>版本</h4><hr><p><img src="http://upload-images.jianshu.io/upload_images/1043168-77c8023387b75a0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h4 id="一-首先下载搭建环境所需要的软件"><a href="#一-首先下载搭建环境所需要的软件" class="headerlink" title="一.首先下载搭建环境所需要的软件"></a>一.首先下载搭建环境所需要的软件</h4><p>1.<a href="http://pan.baidu.com/s/1kUShXXH" target="_blank" rel="noopener">phpstorm</a> 密码: jebr<br>2.<a href="http://pan.baidu.com/s/1cAzFbC" target="_blank" rel="noopener">mamp pro</a>密码: mhia<br>3.<code>chrome</code><br>4.<code>JetBrains IDE Support</code>(<code>chrome</code>插件)</p><h4 id="二-安装成功之后配置mamp"><a href="#二-安装成功之后配置mamp" class="headerlink" title="二.安装成功之后配置mamp"></a>二.安装成功之后配置<code>mamp</code></h4><h5 id="新建一个server目录"><a href="#新建一个server目录" class="headerlink" title="新建一个server目录"></a>新建一个<code>server</code>目录</h5><p><img src="http://upload-images.jianshu.io/upload_images/1043168-9107bcd5b20e92fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>默认会生成以下两个文件</p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-0dc20a4ec6ec7c39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h5 id="mamp是自带xdebug的-因此我们不需要brew来安装xdebug-直接启用"><a href="#mamp是自带xdebug的-因此我们不需要brew来安装xdebug-直接启用" class="headerlink" title="mamp是自带xdebug的,因此我们不需要brew来安装xdebug,直接启用"></a><code>mamp</code>是自带<code>xdebug</code>的,因此我们不需要<code>brew</code>来安装<code>xdebug</code>,直接启用</h5><p><img src="http://upload-images.jianshu.io/upload_images/1043168-de5ea90e78910a16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>启动<code>serve</code>之后默认会跳转<code>mamp</code>的信息界面</p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-78f92245a8c95bb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>点击菜单栏的<code>phpinfo</code>,边可以看到<code>php</code>的相关配置</p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-c7221e100e227a21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png">然后再</p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-c72e6f06475911ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h4 id="三-配置phpstorm"><a href="#三-配置phpstorm" class="headerlink" title="三.配置phpstorm"></a>三.配置phpstorm</h4><p>删掉index.php的所有代码输入一段测试代码</p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-e64e93dfc98312ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>配置项目的运行环境<br><img src="http://upload-images.jianshu.io/upload_images/1043168-f01486f4c74b90ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>选择<code>php</code>位置</p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-7238d1a2be375612.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>然后<code>apply  ok</code><br>修改端口</p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-2e9ec88b288666c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>配置<code>DBCpProxy</code><br><img src="http://upload-images.jianshu.io/upload_images/1043168-ac0179546718cf5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-ed739d041ff7c1b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1043168-fbaacaee82cc7a4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h4 id="四-chromeJetBrains-IDE-Support-Chrome插件并启用"><a href="#四-chromeJetBrains-IDE-Support-Chrome插件并启用" class="headerlink" title="四.chromeJetBrains IDE Support Chrome插件并启用"></a>四.chrome<a href="http://www.cnplugins.com/devtool/jetbrains-ide-support/download.html" target="_blank" rel="noopener">JetBrains IDE Support Chrome插件</a>并启用</h4><h4 id="五-打断点调试"><a href="#五-打断点调试" class="headerlink" title="五.打断点调试"></a>五.打断点调试</h4><p><img src="http://upload-images.jianshu.io/upload_images/1043168-3c54ec7f5a75bed9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Mac&lt;/code&gt;搭建&lt;code&gt;PHP&lt;/code&gt;开发环境(&lt;code&gt;mamp&lt;/code&gt;+&lt;code&gt;phpstorm&lt;/code&gt;+&lt;code&gt;xdebug&lt;/code&gt;)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://chiseller.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://chiseller.github.io/tags/PHP/"/>
    
      <category term="MAC" scheme="https://chiseller.github.io/tags/MAC/"/>
    
  </entry>
  
</feed>
