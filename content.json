{"meta":{"title":"Fingle","subtitle":"fingle","description":"你脖子扬起来，看云，云就散了；看雨，雨就收了；看我，我就酥了！","author":"fingle","url":"https://chiseller.github.io"},"pages":[],"posts":[{"title":"技术支持","slug":"技术支持","date":"2020-09-07T12:40:38.000Z","updated":"2020-09-09T12:57:08.441Z","comments":true,"path":"2020/09/07/技术支持/","link":"","permalink":"https://chiseller.github.io/2020/09/07/技术支持/","excerpt":"","text":"一. 如何同步设备信息? 确保设备处于“已绑定”的情况下，点击云端“刷新”按钮即可绑定设备至当前APP登录账户 二. 同步后有什么好处？ 绑定设备发出的告警信息将实时正确推送至对应的APP，或者发短信至对应手机号码 三. 如何对设备进行续费？ 点击续费按钮查看金额，然后通过支付宝进行充值，在充值完成后即可通过续费功能续费。 四. 联系方式 售前邮箱： Biz@smartreefs.com技术支持： reffe@qq.com","categories":[{"name":"App","slug":"App","permalink":"https://chiseller.github.io/categories/App/"}],"tags":[{"name":"Support","slug":"Support","permalink":"https://chiseller.github.io/tags/Support/"}],"keywords":[{"name":"App","slug":"App","permalink":"https://chiseller.github.io/categories/App/"}]},{"title":"HTTP与HTTPS握手的那些事","slug":"HTTP与HTTPS","date":"2018-05-22T12:40:38.000Z","updated":"2020-09-09T12:36:27.002Z","comments":true,"path":"2018/05/22/HTTP与HTTPS/","link":"","permalink":"https://chiseller.github.io/2018/05/22/HTTP与HTTPS/","excerpt":"HTTPS握手的过程以及为什么HTTPS是安全的。在讲述这两个握手时候，有一些东西需要提前说明。","text":"HTTPS握手的过程以及为什么HTTPS是安全的。在讲述这两个握手时候，有一些东西需要提前说明。 一、前言1. HTTP与TCP/IP区别？TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。下面的图表试图显示不同的TCP/IP和其他的协议在最初OSI（Open System Interconnect）模型中的位置： 分层 名称 协议 7 应用层 HTTP、SMTP、SNMP、FTP、Telnet、SP、SSH、NFS、RTSP、XMPP、Whois、ENRP 6 表示层 XDR、ASN1、SMB、AFP、NCP 5 会话层 ASAP、TLS、SSH、ISO8327/ CCITT X225、RPC、 NetBIOS、ASP、 Winsock、 BSD Sock 4 传输层 TCP、UDP、RTP、SCTP、SPX、ATPIL 3 网络层 IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X25 2 数据链路层 以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE802.11、FDDI、PPP 1 物理层 线路、无线电、光纤、信鸽 2. CA证书是什么？CA（Certificate Authority）是负责管理和签发证书的第三方权威机构，是所有行业和公众都信任的、认可的。CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。 二、HTTP三次握手HTTP（HyperText Transfer Protocol)超文本传输协议是互联网上应用最为广泛的一种网络协议。由于信息是明文传输，所以被认为是不安全的。而关于HTTP的三次握手，其实就是使用三次TCP握手确认建立一个HTTP连接。如下图所示，SYN（synchronous）是TCP/IP建立连接时使用的握手信号、Sequence number（序列号）、Acknowledge number（确认号码），三个箭头指向就代表三次握手，完成三次握手，客户端与服务器开始传送数据。 1. 第一次握手： 客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；2. 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；3. 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 三、HTTPS握手过程HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。具体是如何进行加密，解密，验证的，且看下图，下面的称为一次握手。 1. 客户端发起HTTPS请求 2. 服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。 3. 传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。 4. 客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。 5. 传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 6. 服务段解密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 7. 传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 8. 客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。 ###三、HTTPS一般使用的加密与HASH算法： 非对称加密算法：RSA，DSA/DSS 对称加密算法：AES，RC4，3DES HASH算法：MD5，SHA1，SHA256","categories":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}],"tags":[{"name":"Works","slug":"Works","permalink":"https://chiseller.github.io/tags/Works/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}]},{"title":"我的作品链接","slug":"我的作品链接","date":"2018-05-22T12:40:38.000Z","updated":"2020-09-09T12:36:27.011Z","comments":true,"path":"2018/05/22/我的作品链接/","link":"","permalink":"https://chiseller.github.io/2018/05/22/我的作品链接/","excerpt":"有一部分软件已经下架或者需要硬件支持，如果不能下载请查看作品截图。","text":"有一部分软件已经下架或者需要硬件支持，如果不能下载请查看作品截图。 一. 便利家（业主） App截图（已下架） 二. 便利家（物业） App截图（已下架） 三. 到此一游 App截图 （已上架） 链接 四. 出格 App截图 （上架中) 四. SmartReefs App截图 （已上架) 链接","categories":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}],"tags":[{"name":"Works","slug":"Works","permalink":"https://chiseller.github.io/tags/Works/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}]},{"title":"iOS视频开发（二）","slug":"iOS视频开发（二）","date":"2016-05-04T11:05:57.000Z","updated":"2020-09-09T12:36:27.010Z","comments":true,"path":"2016/05/04/iOS视频开发（二）/","link":"","permalink":"https://chiseller.github.io/2016/05/04/iOS视频开发（二）/","excerpt":"此文是iOS视频开发的第二篇，相比第一篇来说视频和音频的可定制化更加多样化，本文总结的只是一些简单的知识，通过此文可以对音视频的采集和编辑有大致的了解。 通过AVAssetWriter和AVCaptureSession此文系列的第一篇已经对AVCaptureSession录制视频的基本过程有了大致的介绍，AVCaptureSession和AVAssetWriter的基本步骤类似，但是通过AVAssetWriter可以实现更高度化的音视频编辑功能，设置视频和音频的一些属性，给视频加滤镜，音频变声等功能。","text":"此文是iOS视频开发的第二篇，相比第一篇来说视频和音频的可定制化更加多样化，本文总结的只是一些简单的知识，通过此文可以对音视频的采集和编辑有大致的了解。 通过AVAssetWriter和AVCaptureSession此文系列的第一篇已经对AVCaptureSession录制视频的基本过程有了大致的介绍，AVCaptureSession和AVAssetWriter的基本步骤类似，但是通过AVAssetWriter可以实现更高度化的音视频编辑功能，设置视频和音频的一些属性，给视频加滤镜，音频变声等功能。 基本步骤 初始化一个AVCaptureSession类 获取音频device和视频device 初始化videoInput&amp;audioInput 初始化videoDataOutPut以及audioDataOutPut以及分别对应的queue 获取videoConnection和audioConnection 将Input和output加入AVCaptureSession 初始化AVAssetWriter 1~3请参考前文。 四、建立videoOutput和videoOutput//audioOutput - (AVCaptureAudioDataOutput *)audioDataOutput{ if (!_audioDataOutput) { _audioDataOutput = [[AVCaptureAudioDataOutput alloc]init]; //设置音频输出队列 [_audioDataOutput setSampleBufferDelegate:self queue:self.audioDataOutputQueue]; } return _audioDataOutput; } //videoOutput -(AVCaptureVideoDataOutput *)videoDataOutput{ if (!_videoDataOutput) { _videoDataOutput = [[AVCaptureVideoDataOutput alloc]init]; _videoDataOutput.videoSettings = nil; _videoDataOutput.alwaysDiscardsLateVideoFrames = NO; //设置视频输出队列 [_videoDataOutput setSampleBufferDelegate:self queue:self.videoDataOutputQueue]; } return _videoDataOutput; } 五、获取videoConnection和audioConnection_videoConnection = [self.videoDataOutput connectionWithMediaType:AVMediaTypeVideo]; _audioConnection = [self.audioDataOutput connectionWithMediaType:AVMediaTypeAudio]; 6、将Input和output加入AVCaptureSession _session = [[AVCaptureSession alloc]init]; // 设置视频质量 if ([_session canSetSessionPreset:AVCaptureSessionPresetHigh]) { [_session setSessionPreset:AVCaptureSessionPresetHigh]; } if ([_session canAddInput:self.videoInput]) { [_session addInput:self.videoInput]; } if ([_session canAddInput:self.audioInput]) { [_session addInput:self.audioInput]; } if ([_session canAddOutput:self.videoDataOutput]) { [_session addOutput:self.videoDataOutput]; } _videoConnection = [self.videoDataOutput connectionWithMediaType:AVMediaTypeVideo]; if ([_session canAddOutput:self.audioDataOutput]) { [_session addOutput:self.audioDataOutput]; } _audioConnection = [self.audioDataOutput connectionWithMediaType:AVMediaTypeAudio]; 七、AVAssetWriter//一个url路径对应一个AVAssetWriter _assetWriter = [[AVAssetWriter alloc]initWithURL:filePathUrl fileType:AVFileTypeQuickTimeMovie error:&amp;error]; if (error) { NSLog(@&quot;%@&quot;,error.localizedDescription); return; } dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{ @autoreleasepool { // 视频属性 if ([_assetWriter canApplyOutputSettings:self.videoCompressionSettings forMediaType:AVMediaTypeVideo]) { self.videoAssetWriterInput = [[AVAssetWriterInput alloc]initWithMediaType:AVMediaTypeVideo outputSettings:self.videoCompressionSettings]; self.videoAssetWriterInput.expectsMediaDataInRealTime = YES; if([_assetWriter canAddInput:self.videoAssetWriterInput]){ [_assetWriter addInput:self.videoAssetWriterInput]; } } // 音频属性 NSDictionary * audioSettings = @{ AVFormatIDKey : @(kAudioFormatMPEG4AAC) }; if ([_assetWriter canApplyOutputSettings:audioSettings forMediaType:AVMediaTypeAudio]) { self.audioAssetWriterInput = [[AVAssetWriterInput alloc]initWithMediaType:AVMediaTypeAudio outputSettings:audioSettings sourceFormatHint:self.outputAudioFormatDescription]; self.audioAssetWriterInput.expectsMediaDataInRealTime = YES; if ([_assetWriter canAddInput:self.audioAssetWriterInput]) { [_assetWriter addInput:self.audioAssetWriterInput]; } } [_assetWriter startWriting]; } }); 代理中写入CMSampleBufferRef- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection{ // 不要渲染第一个采样缓冲区。 第一个采样缓冲区标识视频的信息 // 提供(33ms at 30fps)针间隔 // 最好异步执行，防止在帧无法在读写比较慢的设备上缓存 // 当视频的设置更改之后，此信息也需要更新 CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer); CFRetain(sampleBuffer); if (connection == self.videoConnection) { if (self.outputVideoFormatDescription == nil) { self.outputVideoFormatDescription = formatDescription; }else{ self.outputVideoFormatDescription = formatDescription; dispatch_async(self.writingQueue, ^{ @autoreleasepool { @synchronized(self){ if (_assetWriter.status != 1) { CFRelease(sampleBuffer); return ; } if (!_sessionStart) { [_assetWriter startSessionAtSourceTime:CMSampleBufferGetPresentationTimeStamp(sampleBuffer)]; _sessionStart = YES; } if (self.videoAssetWriterInput.readyForMoreMediaData &amp;&amp; _assetWriter.status ==1) { BOOL su = [self.videoAssetWriterInput appendSampleBuffer:sampleBuffer]; if (!su) { NSLog(@&quot;%@ ---video&quot;, _assetWriter.error.localizedDescription); } } CFRelease(sampleBuffer); } } }); } }else if(connection == self.audioConnection){ self.outputAudioFormatDescription = formatDescription; dispatch_async(self.writingQueue, ^{ @synchronized(self){ if (_assetWriter.status != 1) { CFRelease(sampleBuffer); return; } if(self.audioAssetWriterInput.readyForMoreMediaData &amp;&amp; _assetWriter.status == 1){ BOOL su = [self.audioAssetWriterInput appendSampleBuffer:sampleBuffer]; if (!su) { NSLog(@&quot;%@&quot;,_assetWriter.error.localizedDescription); } } CFRelease(sampleBuffer); } }); } } 大致就是这么一个流程，但是其中涉及的东西特别多，还不能一一的列举出来，接下来的时间里再慢慢研究这方面的东西吧。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}]},{"title":"iOS视频开发（一）","slug":"iOS视频开发（一）","date":"2016-05-03T01:05:57.000Z","updated":"2020-09-09T12:36:27.009Z","comments":true,"path":"2016/05/03/iOS视频开发（一）/","link":"","permalink":"https://chiseller.github.io/2016/05/03/iOS视频开发（一）/","excerpt":"一、UIImagePickerControllerUIImagePickerController是UIKit框架里面的一个class，通过这个系统提供的class我们可以简单的是实现拍照、录制视频和音频。","text":"一、UIImagePickerControllerUIImagePickerController是UIKit框架里面的一个class，通过这个系统提供的class我们可以简单的是实现拍照、录制视频和音频。 三个步骤： 当前控制器present一个UIImagePickerController类 在当前界面就可以拍照、录制视频和音频 实现UIImagePickerController的delegate，在delegate可以获取录制的视频和音频，来进行相应的操作. 定制化UIImagePickerController // 查看摄像头是否可用 if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera] == NO) { return; } UIImagePickerController *imagePick = [[UIImagePickerController alloc]init]; imagePick.sourceType = UIImagePickerControllerSourceTypeCamera; // 我们还可以设置照片和视频拍摄的质量、是否可以开启闪光灯、是否开启手电筒 // 还可以单独设置只支持视频模式 // imagePick.mediaTypes = [[NSArray alloc] initWithObjects: (NSString *) kUTTypeMovie, nil]; imagePick.mediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera]; // UINavigationControllerDelegate,UIImagePickerControllerDelegate; imagePick.delegate = self; //拍照或者录制结束后是否可以编辑 imagePick.allowsEditing = NO; [self presentViewController:imagePick animated:YES completion:nil]; 界面的自定义cameraOverlayView属性可以自定义UIImagePickerController界面顶部的控件，但是只在UIImagePickerController的mediaTypes为UIImagePickerControllerSourceTypeCamera时可用。 实现UIImagePickerController的delegate- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info{ NSString *mediaType = [info objectForKey:UIImagePickerControllerMediaType]; UIImage *originalImage, *editedImage, *imageToSave; // 处理图片 if ([mediaType isEqualToString:(NSString *)kUTTypeImage]) { editedImage = info[UIImagePickerControllerOriginalImage]; originalImage = info[UIImagePickerControllerEditedImage]; if (editedImage) { imageToSave = editedImage; }else{ imageToSave = originalImage; } UIImageWriteToSavedPhotosAlbum(imageToSave, nil, nil, nil); } //处理视频 if ([mediaType isEqualToString:(NSString *)kUTTypeMovie]) { NSString *url = [info[UIImagePickerControllerMediaURL] path]; if (UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(url)) { UISaveVideoAtPathToSavedPhotosAlbum(url, nil, nil, nil); } } [picker dismissViewControllerAnimated:YES completion:nil]; } 二、AVCaptureSession &amp; AVCaptureMovieFileOutput 要获取摄像机捕捉到的视频或者麦克风捕捉到的音频，我们需要对象表示inputs和outputs，并使用AVCaptureSession的实例来协调它们之间的数据流。 AVCaptureDevice 对象，表示声音或者视频采集设备，对应摄像头和麦克风。 AVCaptureInput的子类，配置输入端口。 AVCaptureOutput的子类， 输出采集到的视频或者图像。 AVCaptureSession来协调从输入到输出的数据流。 步骤一： 创建AVCaptureDevice 对象因为我们需要录制视频和音频所以我们需要视频的AVCaptureDevice和音频的AVCaptureDevice。 //我们同时获取了前摄像头和后摄像头因为等会我们要手动切换 //获取音频device -(AVCaptureDevice *)audioDevice{ if (!_audioDevice) { _audioDevice = [AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio].firstObject; } return _audioDevice; } //后置摄像头 -(AVCaptureDevice *)backVideoDevice{ if (!_backVideoDevice) { _backVideoDevice = [self getDeviceBy:AVCaptureDevicePositionBack]; if ([self.currentVideoDevice isTorchAvailable] &amp;&amp; [_backVideoDevice isTorchModeSupported:AVCaptureTorchModeOn]) { //可以设置是否开启闪光灯，是否开始HDR、视频防抖、白平衡什么的 //设置device之前需要先 lockForConfiguration if ([_backVideoDevice lockForConfiguration:NULL]==YES) { self.currentVideoDevice.torchMode = AVCaptureTorchModeOn; [self.currentVideoDevice unlockForConfiguration]; } } } } return _backVideoDevice; } //前置摄像头 -(AVCaptureDevice *)frontVideoDevice{ if (!_frontVideoDevice) { _frontVideoDevice = [self getDeviceBy:AVCaptureDevicePositionFront]; } return _frontVideoDevice; } 步骤二、配置inputs每个AVCaptureDevice对应一个input。 //audio input - (AVCaptureDeviceInput *)audioInput{ if (!_audioInput) { NSError *error = nil; _audioInput = [AVCaptureDeviceInput deviceInputWithDevice:self.audioDevice error:&amp;error]; } return _audioInput; } - (AVCaptureDeviceInput *)videoInput{ if (!_videoInput) { NSError *error = nil; _videoInput = [AVCaptureDeviceInput deviceInputWithDevice:self.currentVideoDevice error:&amp;error]; } return _videoInput; } 步骤三: 写入文件Output有四种： AVCaptureMovieFileOutput 写入文件AVCaptureVideoDataOutput 加工视频输出AVCaptureAudioDataOutput 加工音频输出AVCaptureStillImageOutput 捕捉输出的图像 写入文件只需要AVCaptureMovieFileOutput就可以了。 // output - (AVCaptureMovieFileOutput *)movieFileOutput{ if (!_movieFileOutput) { _movieFileOutput = [[AVCaptureMovieFileOutput alloc]init]; //CMTime drution = CMTimeMake(1, 60); //设置视频录制时间限制 kCMTimeInvalid(无限制) _movieFileOutput.maxRecordedDuration = kCMTimeInvalid; // 文件大小限制 //_movieFileOutput.maxRecordedFileSize = 1024 * 1024; AVCaptureConnection *videoConnection = [_movieFileOutput connectionWithMediaType:AVMediaTypeVideo]; // 是否支持科学防抖 if ([videoConnection isVideoStabilizationSupported]) { videoConnection.preferredVideoStabilizationMode = AVCaptureVideoStabilizationModeAuto; } videoConnection.videoOrientation = self.previewLayer.connection.videoOrientation; } return _movieFileOutput; } 步骤四： 获取AVCaptureSession- (AVCaptureSession *)session{ if (!_session) { _session = [[AVCaptureSession alloc]init]; // 设置视频质量 if ([_session canSetSessionPreset:AVCaptureSessionPresetLow]) { [_session setSessionPreset:AVCaptureSessionPresetLow]; } //增加videoinput if ([_session canAddInput:self.videoInput]) { [_session addInput:self.videoInput]; } //增加videoinput if ([_session canAddInput:self.audioInput]) { [_session addInput:self.audioInput]; } //增加fileOutput if ([_session canAddOutput:self.movieFileOutput]) { [_session addOutput:self.movieFileOutput]; } } return _session; } 这个地方需要注意下，每次我们更改AVCaptureSession的属性的时候我们都需要： [session beginConfiguration]; // Remove an existing capture device. // Add a new capture device. // Reset the preset. [session commitConfiguration]; 现在就可以录制视频并写入文件了为了实时查看我们录制的内容，我们加一个预览层。 -(AVCaptureVideoPreviewLayer *)previewLayer{ if (!_previewLayer) { _previewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.session]; _previewLayer.frame = [UIScreen mainScreen].bounds; _previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill; _previewLayer.connection.videoOrientation = AVCaptureVideoOrientationPortrait; } return _previewLayer; } 在控制器里面调用session的startRuning方法，这个时候只是采集到了视频显示在了预览层上面，并未开始录制。 - (void)viewDidLoad { [super viewDidLoad]; self.recodingView.delegate = self; [self.view.layer insertSublayer:self.previewLayer atIndex:0]; [self.session startRunning]; } 点击录制视频,recodingView是我自定义的控件。 -(void)writePath{ if ([self.movieFileOutput isRecording] ) { [self.movieFileOutput stopRecording]; return; } NSDateFormatter * dateFormatter = [[NSDateFormatter alloc] init ]; [dateFormatter setDateFormat:@&quot;yyyyMMddHHmmss&quot;]; NSString * fileName = [[dateFormatter stringFromDate:[NSDate date]] stringByAppendingString:@&quot;.mov&quot;]; NSString * filePath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:fileName]; NSURL *filePathUrl = [NSURL fileURLWithPath:filePath]; //写文件到指定的路径，并设置代理 [self.movieFileOutput startRecordingToOutputFileURL:filePathUrl recordingDelegate:self]; } 设置代理,在视频录制的过程中会发生许多情况，比如说突然来电话，摄像头被其他程序占用，系统会发送相应的通知给我们。 - (void)captureOutput:(AVCaptureFileOutput *)captureOutput didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL fromConnections:(NSArray *)connections error:(NSError *)error{ BOOL recordSuccessfully = YES; if ([error code] != noErr) { id value = [[error userInfo] objectForKey:AVErrorRecordingSuccessfullyFinishedKey]; if (value) { recordSuccessfully = [value boolValue]; } } // 有`error`的话 有可能也是录制成功了 /* AVErrorMaximumDurationReached 时间限制 AVErrorMaximumFileSizeReached 文件大小限制 AVErrorDiskFull 磁盘已满 AVErrorDeviceWasDisconnected device连接失败 AVErrorSessionWasInterrupted 被切断（比如说来电话了） */ }","categories":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}]},{"title":"在centos上搭建git服务器","slug":"POST和PUT请求的区别","date":"2015-07-02T06:35:57.000Z","updated":"2020-09-09T12:36:27.008Z","comments":true,"path":"2015/07/02/POST和PUT请求的区别/","link":"","permalink":"https://chiseller.github.io/2015/07/02/POST和PUT请求的区别/","excerpt":"","text":"POST和PUT请求的区别1.什么是幂等性 幂等性概念：幂等通俗来说是指不管进行多少次重复操作，都是实现相同的结果。 2.REST请求中哪些是幂等操作GET，PUT，DELETE都是幂等操作，而POST不是. 1.首先GET请求很好理解，对资源做查询多次，此实现的结果都是一样的。 2.PUT请求的幂等性可以这样理解，将A修改为B，它第一次请求值变为了B，再进行多次此操作，最终的结果还是B，与一次执行的结果是一样的，所以PUT是幂等操作。 3.同理可以理解DELETE操作，第一次将资源删除后，后面多次进行此删除请求，最终结果是一样的，将资源删除掉了。 4.POST不是幂等操作，因为一次请求添加一份新资源，二次请求则添加了两份新资源，多次请求会产生不同的结果，因此POST不是幂等操作。 ####3 根据幂等性区分POST与PUT的使用了解REST后很长一段时间不能明确区分PUT和POST的区别，在使用时很容易混淆，完全可根据idempotent（幂等性）做区分。 假如有一个博客系统提供一个Web API，模式是这样http://superblogging/blogs/{blog-name}，很简单，将{blog-name}替换为我们的blog名字，往这个URI发送一个HTTP PUT或者POST请求，HTTP的body部分就是博文，这是一个很简单的REST API例子。 我们应该用PUT方法还是POST方法？ 取决于这个REST服务的行为是否是idempotent的，假如我们发送两个http://superblogging/blogs/post/Sample请求，服务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。","categories":[{"name":"linux","slug":"linux","permalink":"https://chiseller.github.io/categories/linux/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://chiseller.github.io/tags/bash/"},{"name":"git","slug":"git","permalink":"https://chiseller.github.io/tags/git/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"https://chiseller.github.io/categories/linux/"}]},{"title":"在centos上搭建git服务器","slug":"在centos上搭建git服务器","date":"2015-07-02T06:35:57.000Z","updated":"2020-09-09T12:36:27.010Z","comments":true,"path":"2015/07/02/在centos上搭建git服务器/","link":"","permalink":"https://chiseller.github.io/2015/07/02/在centos上搭建git服务器/","excerpt":"刚开始搭建blog的时候打算用ftp的,可是期间遇到了各种问题,最后选择了git,其实现在想想遇到的大部分问题应该全是权限的问题,毕竟对linux的认识只能说算是刚刚起步,等有空的时候再去好好研究吧.","text":"刚开始搭建blog的时候打算用ftp的,可是期间遇到了各种问题,最后选择了git,其实现在想想遇到的大部分问题应该全是权限的问题,毕竟对linux的认识只能说算是刚刚起步,等有空的时候再去好好研究吧. vps(系统centos6.2,git版本1.7) 安装git方法一.yum install -y git(最简单的方法)方法二.下载git源码编译安装,需要安装编译工具(不做介绍) 建立git用户(可选)注意:有些系统在你安装git的时候,可能已经给你自动建立了git用户,因此你可以忽略这一步. 添加git用户 //自动在home下建立git目录 useradd git //切换到/home下查看 ls -al //注意一定要注意查看git目录的拥有者(必须是git)和所属用户组(可以是git或者root), //否则在以后设置免密码clone和push的时候会出现Permission denied error的错误. //修改git目录拥有者和所属群组为git chown -R git:git git 修改git用户的操作权限vi /etc/passwd //找到git用户的那一行,修改如下:不允许git用户的ssh登录 git:x:500:500::/home/git:/usr/bin/git-shell 在服务器上建立裸版本库mkdir /home/testgit //这里 git init 是初始化空仓库的意思，而参数 --bare 是代表创建裸仓库，而参数 --bare 是代表创建裸仓库 git init --bare sample.git 注意:一定要查看testgit目录的拥有者(必须是git)和所属用户组(可以是git或者root),否则在以后设置免密码clone和push的时候会出现Permission denied error的错误. clone远程仓库cd Desktop git clone git@115.159.146.94:/home/testgit/sample.git //这时候会让你输入git的密码,但是我们并没有设置git用户的密码 配置公钥进行免密码登录 clone和pushmac下的公钥和密钥在 ~/.ssh下 cd ~/.ssh ls -a //会看到如下文件(如果没有请查看如何生成公钥和密钥) id_rsa(密钥) id_rsa.pub(公钥) known_host //生成公密钥 终端 ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/home/fdipzone/.ssh/id_rsa): 这里输入要生成的文件名 Enter passphrase (empty for no passphrase): 这里输入密码 Enter same passphrase again: 这里重复输入密码 Your identification has been saved in /home/fdipzone/.ssh/id_rsa. Your public key has been saved in /home/fdipzone/.ssh/id_rsa.pub. The key fingerprint is: f2:76:c3:6b:26:10:14:fc:43:e0:0c:4d:51:c9:a2:b0 The key&#39;s randomart image is: +--[ RSA 2048]----+ | .+=*.. | | . += + | | o oo+ | | E . . o | | ..S. | | .o . | | .o + | | ...oo | | +. | +-----------------+ //密钥生成成功 在centos cd /home/git/.ssh //建立授权文件 authorized_keys,文件不存在则自己新建一个 //将本地机器上的 id_rsa.pub(公钥)里面的复制一份粘贴到centos下/home/git/.ssh/authorized_keys authorized_keys文件看起来是这样的,上下两个免密码登录用户的公钥 ,上下分开. ###注意: .ssh 和 authorized_keys的拥有者必须是git,否则还是会有权限不足的问题 同步代码到自己的博客站点目录比如说我们的博客有一点点的优化,但是push代码之后无法立即查看效果,这个地方我们就需要自动同步就派上用场了。自动同步功能用到的是 git 的钩子功能， cd /home/testgit/sample.git cd hooks //这里我们创建post-receive文件 vi post-receive //在该文件里输入以下内容./home/www就是我blog站点的目录 #!/bin/bash git --work-tree=/home/www checkout -f //保存退出后，将该文件用户及用户组都设置成 gitchown git:git post-receive //由于该文件其实就是一个shell文件，我们还应该为其设置可执行权限 chmod +x post-receive 此时clone自己的blog站点,修改一下网站的名称,push到git服务器,刷新网站首页,是不是发现自己blog的名称变了! 最后再记录一下,配置ssh 免密码登录(so easy)复制自己主机下的公钥内容在自己的vps下 vi /root/.ssh/ authorized_keys //复制密钥内容进去,好了,现在ssh也可以免密码登录了","categories":[{"name":"linux","slug":"linux","permalink":"https://chiseller.github.io/categories/linux/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://chiseller.github.io/tags/bash/"},{"name":"git","slug":"git","permalink":"https://chiseller.github.io/tags/git/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"https://chiseller.github.io/categories/linux/"}]},{"title":"JavaScriptCore的基本用法（二）","slug":"JavaScriptCore的基本用法2","date":"2015-06-07T16:00:00.000Z","updated":"2020-09-09T12:36:27.007Z","comments":true,"path":"2015/06/08/JavaScriptCore的基本用法2/","link":"","permalink":"https://chiseller.github.io/2015/06/08/JavaScriptCore的基本用法2/","excerpt":"这是JavaScriptCore的第二篇","text":"这是JavaScriptCore的第二篇 代理设置（JS调用OC的第二种方法）h文件 //首先写一个协议 遵守JSExport协议 @protocol JSExportTest &lt;JSExport&gt; //宏转换下，将JS函数名称指定为Add； JSExportAs(add, - (NSInteger)add:(NSInteger)a b:(NSInteger)b); @property (nonatomic, assign) NSInteger sum; @end //建一个对象实现这个协议 @interface JSTest : NSObject&lt;JSExportTest&gt; @end m文件 @implementation JSTest @synthesize sum = _sum; //实现协议方法 - (NSInteger)add:(NSInteger)a b:(NSInteger)b{ return a + b; } -(void)setSum:(NSInteger)sum{ NSLog(@&quot;%ld&quot;,(long)sum); _sum = sum; } @end 在viewcontroller里面 JSContext *context = [[JSContext alloc] init]; //设置异常处理 self.context.exceptionHandler = ^(JSContext *context, JSValue *exception) { [JSContext currentContext].exception = exception; NSLog(@&quot;exception:%@&quot;,exception); }; //将obj添加到context中 scontext[@&quot;obj&quot;] = [][JSTest alloc]init]; //JS里面调用obj方法，并将结果赋值给obj的sum属性 [context evaluateScript:@&quot;obj.sum = obj.add(2,3)&quot;]; 在JS中进行调用这个对象的方法，并将结果赋值sum。唯一要注意的是OC的函数命名和JS函数命名规则问题。协议中定义的是add: b:，但是JS里面方法名字是add(a,b)。可以通过JSExportAs这个宏转换成JS的函数名字。 异常处理Objective-C的异常会在运行时被Xcode捕获，而在JSContext中执行的JavaScript如果出现异常，只会被JSContext捕获并存储在exception属性上，而不会向外抛出。时时刻刻检查JSContext对象的exception是否不为nil显然是不合适，更合理的方式是给JSContext对象设置exceptionHandler，它接受的是^(JSContext *context, JSValue *exceptionValue)形式的Block。其默认值就是将传入的exceptionValue赋给传入的context的exception属性： JSContext *context = [[JSContext alloc] init]; context.exceptionHandler = ^(JSContext *con, JSValue *exception) { NSLog(@&quot;%@&quot;, exception); con.exception = exception; }; [context evaluateScript:@&quot;fengzhen = 66&quot;]; //输出: // ReferenceError: Can&#39;t find variable: fengzhen 无论是把Block传给JSContext对象让其变成avaScript方法，还是把它赋给exceptionHandler属性，在Block内都不要直接使用其外部定义的JSContext对象或者JSValue，应该将其当做参数传入到Block中，或者通过JSContext的类方法+ (JSContext *)currentContext;来获得。否则会造成循环引用使得内存无法被正确释放。 内存管理OC使用的是ARC，JS使用的是垃圾回收机制，js的引用全都是强引用，垃圾回收机制会帮他们打破这种强引用，所以JS不存在循环引用的问题。一般情况下，OC和JS对象之间内存管理都无需我们去关心。不过还是有几个注意点需要我们去留意下。 不要在block里面直接使用context，或者使用外部的JSValue对象。JSContext *context = [[JSContext alloc] init]; //设置异常处理 self.context.exceptionHandler = ^(JSContext *context, JSValue *exception) { //直接这么使用是错误的 //context.exception = exception; [JSContext currentContext].exception = exception; NSLog(@&quot;exception:%@&quot;,exception); }; OC对象不要用属性直接保存JSValue对象，因为这样太容易造成循环引用。下面的例子： #import &lt;Foundation/Foundation.h&gt; #import &lt;JavaScriptCore/JavaScriptCore.h&gt; //首先写一个协议 遵守JSExport协议 @protocol JSExportTest &lt;JSExport&gt; //宏转换下，将JS函数名称指定为Add； JSExportAs(add, - (NSInteger)add:(NSInteger)a b:(NSInteger)b); @property (nonatomic, strong) JSValue *value; @end //建一个对象实现这个协议 @interface JSTest : NSObject&lt;JSExportTest&gt; @end #import &quot;JSTest.h&quot; @implementation JSTest @synthesize value = _value; //实现协议方法 -(void)setValue:(JSValue *)value{ _value = value; } @end viewController里面 JSContext *context = [[JSContext alloc]init]; context.exceptionHandler = ^(JSContext *j, JSValue *v){ NSLog(@&quot;%@&quot;,j.exception); }; [context evaluateScript:@&quot;function callback(){return &#39;hello world&#39;};function setObj(obj){this.obj = obj;obj.value = callback}&quot;]; [context[@&quot;setObj&quot;] callWithArguments:@[self.testObj]]; 调用JS方法，进行赋值，JS对象保留了传进来的obj，最后，JS将自己的回调callback赋值给了obj，方便obj下次回调给JS；由于JS那边保存了obj，而且obj这边也保留了JS的回调。这样就形成了循环引用。为了打破这种强引用，apple有一个JSManagedValue 的类，官方的原话： The JSManagedValue&#39;s JavaScript value is reachable from JavaScript The owner of the managed reference is reachable in Objective-C. Manually adding or removing the managed reference in the JSVirtualMachine determines reachability. JSManagedValue 帮助我们保存JSValue，里面保存的JS对象必须在JS中存在，同时 JSManagedValue 的owner在OC中也存在.因此我们把代理的m文件修改如下： -(void)setValue:(JSValue *)value{ // 由于是回掉的关系 obj保存了JS的回掉， js也保存了obj，这样就形成了循环引用 // JSManageValue帮助我们保存了JSValue，哪里保存的js对象在js中存在。 JSMangerValue的owner在OC中也存在。 JSManagedValue *mavalue = [JSManagedValue managedValueWithValue:value]; //建立弱引用关系 [[[JSContext currentContext] virtualMachine] addManagedReference:mavalue withOwner:self]; _value = value; } 不要在不同的 JSVirtualMachine 之间进行传递JS对象。一个JSVirtualMachine可以运行多个context，由于都是在同一个堆内存和同一个垃圾回收下，所以相互之间传值是没问题的。但是如果在不同的 JSVirtualMachine传值，垃圾回收就不知道他们之间的关系了，可能会引起异常。 JavaScriptCore线程是安全的。每个context运行的时候通过lock关联的JSVirtualMachine。如果要进行并发操作，可以创建多个JSVirtualMachine实例进行操作。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chiseller.github.io/tags/JavaScript/"},{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}]},{"title":"JavaScriptCore的基本用法（一）","slug":"JavaScriptCore的基本用法1","date":"2015-05-31T16:00:00.000Z","updated":"2020-09-09T12:36:27.005Z","comments":true,"path":"2015/06/01/JavaScriptCore的基本用法1/","link":"","permalink":"https://chiseller.github.io/2015/06/01/JavaScriptCore的基本用法1/","excerpt":"JavaScriptCore简介iOS 7中加入了JavaScriptCore框架。该框架让Objective-C和JavaScript代码直接的交互变得更加的简单方便。而且使得js可以脱离webview与oc交互。","text":"JavaScriptCore简介iOS 7中加入了JavaScriptCore框架。该框架让Objective-C和JavaScript代码直接的交互变得更加的简单方便。而且使得js可以脱离webview与oc交互。在项目中引入JavaScriptCore后，链到头文件中，除了大段的Copyright注释可以看到里面只要引入了5个文件，每个文件里都定义跟文件名对应的类： JSContext和JSValueJSContext//JSVirtualMachine为JavaScript的运行提供了底层资源，JSContext就为其提供着运行环境,该方法用来执行一段 //JS代码，并且如果其中有方法、变量等信息都会被存储在其中以便在需要的时候使用。 - (JSValue *)evaluateScript:(NSString *)script //JSContext的创建都是基于JSVirtualMachine,如果是使用- (id)init; //进行初始化，那么在其内部会自动创建一个新的JSVirtualMachine //对象然后调用前边的初始化方法 - (id)initWithVirtualMachine:(JSVirtualMachine *)virtualMachine; JSValue则可以说是JavaScript和Object-C之间互换的桥梁，它提供了多种方法可以方便地把JavaScript数据类型转换成Objective-C，或者是转换过去。其一一对应方式可见下表： 基本类型的转换JSContext *context = [[JSContext alloc] init]; JSValue *jsVal = [context evaluateScript:@&quot;2+7&quot;]; int iVal = [jsVal toInt32]; NSLog(@&quot;JSValue: %@, int: %d&quot;, jsVal, iVal); //输出9 还可以存一个Js变量在JSContext中，然后通过下标取出来。对于数组或者对象类型，JSValue也可以通过下表直接取值和赋值. [context evaluateScript:@&quot;var arr = [21, 7 ,&#39;leo&#39;]&quot;]; JSValue *value = context[@&quot;arr&quot;]; value[1] = @&quot;blog&quot;; value[7] = @7; NSArray *array = [value toArray]; 打印数组看一下 Printing description of array: &lt;__NSArrayM 0x7fabc144ea40&gt;( 21, blog, leo, &lt;null&gt;, &lt;null&gt;, &lt;null&gt;, &lt;null&gt;, 7 代码成功把数据从OC\u0010赋值到了Js数组上，而且jsValue遵循js数组的特性，无下标越位，自动延展数组大小 方法的转换（js调用oc的第一种方法）各种数据类型可以转换，Objective-C的Block也可以传入JSContext中当做JavaScript的方法使用。 context[@&quot;add&quot;] = ^(NSInteger a, NSInteger b){ //获取该方法的对象 JSValue *v = [JSContext currentThis]; //获取当前的参数 NSArray *args = [JSContext currentArguments]; NSLog(@&quot;当前对象：%@&quot;,v); NSLog(@&quot;当前参数：%@&quot;,args); NSLog(@&quot;和是%ld&quot;,a + b); }; [context evaluateScript:@&quot;add(1,2)&quot;]; 输出如下： 当前对象：GlobalObject 当前参数：( 1, 2) 和是3 上边的例子中对于”this”输出的内容是GlobalObject，这也是JSContext对象方法- (JSValue *)globalObject;所返回的内容。因为我们知道在JavaScript里，所有全局变量和方法其实都是一个全局变量的属性，在浏览器中是window，在JavaScriptCore是什么就不得而知了。 Block可以传入JSContext作方法，但是JSValue没有toBlock方法来把JavaScript方法变成Block在Objetive-C中使用。毕竟Block的参数个数和类型已经返回类型都是固定的。虽然不能把方法提取出来，但是JSValue提供了- (JSValue )callWithArguments:(NSArray )arguments;方法可以反过来将参数传进去来调用方法。 JSContext *context = [[JSContext alloc]init]; NSString *js = @&quot;function add(a,b){return a+ b;}&quot;; [context evaluateScript:js]; JSValue *value = [context[@&quot;add&quot;] callWithArguments:@[@3,@4]]; NSLog(@&quot;%@&quot;,value); 输出如下： 7 JSValue还提供 - (JSValue *)invokeMethod:(NSString *)method withArguments:(NSArray *)arguments; 让我们可以直接简单地调用对象上的方法。只是如果定义的方法是全局函数，那么很显然应该在JSContext的globalObject对象上调用该方法；如果是某JavaScript对象上的方法，就应该用相应的JSValue对象调用。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chiseller.github.io/tags/JavaScript/"},{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"https://chiseller.github.io/categories/iOS/"}]},{"title":"Mac终端制作带密码的压缩包","slug":"Mac终端制作带密码的压缩包","date":"2015-05-07T03:35:57.000Z","updated":"2020-09-09T12:36:27.008Z","comments":true,"path":"2015/05/07/Mac终端制作带密码的压缩包/","link":"","permalink":"https://chiseller.github.io/2015/05/07/Mac终端制作带密码的压缩包/","excerpt":"刚在网上闲逛看到的，记录一下，以备不时之需 ^_^！","text":"刚在网上闲逛看到的，记录一下，以备不时之需 ^_^！ 1. 只压缩单个文件zip -e yourZipFileName.zip yourSourceFile回车 ，分别输入密码（回车）和确认密码（回车）就OK了。 2. 压缩文件夹zip -e -r yourZipFileName.zip yourSourceFileDir 3. 一行行命令搞定zip -r -P yourPassword yourZipFileName.zip yourSourceFileDir 注意：万一输错密码就悲剧了！！！！！！！","categories":[{"name":"Mac","slug":"Mac","permalink":"https://chiseller.github.io/categories/Mac/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://chiseller.github.io/tags/bash/"},{"name":"Mac","slug":"Mac","permalink":"https://chiseller.github.io/tags/Mac/"}],"keywords":[{"name":"Mac","slug":"Mac","permalink":"https://chiseller.github.io/categories/Mac/"}]},{"title":"Mac搭建PHP开发环境","slug":"Mac搭建PHP开发环境","date":"2015-05-03T01:05:57.000Z","updated":"2020-09-09T12:36:27.007Z","comments":true,"path":"2015/05/03/Mac搭建PHP开发环境/","link":"","permalink":"https://chiseller.github.io/2015/05/03/Mac搭建PHP开发环境/","excerpt":"Mac搭建PHP开发环境(mamp+phpstorm+xdebug)","text":"Mac搭建PHP开发环境(mamp+phpstorm+xdebug) OS版本 一.首先下载搭建环境所需要的软件1.phpstorm 密码: jebr2.mamp pro密码: mhia3.chrome4.JetBrains IDE Support(chrome插件) 二.安装成功之后配置mamp新建一个server目录默认会生成以下两个文件 mamp是自带xdebug的,因此我们不需要brew来安装xdebug,直接启用启动serve之后默认会跳转mamp的信息界面 点击菜单栏的phpinfo,边可以看到php的相关配置 然后再 三.配置phpstorm删掉index.php的所有代码输入一段测试代码 配置项目的运行环境选择php位置 然后apply ok修改端口 配置DBCpProxy 四.chromeJetBrains IDE Support Chrome插件并启用五.打断点调试","categories":[{"name":"PHP","slug":"PHP","permalink":"https://chiseller.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://chiseller.github.io/tags/PHP/"},{"name":"MAC","slug":"MAC","permalink":"https://chiseller.github.io/tags/MAC/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://chiseller.github.io/categories/PHP/"}]}]}